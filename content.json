[{"title":"Servlet","date":"2019-10-17T02:49:22.000Z","path":"2019/10/17/Serverlet/","text":"1. 什么是Servlet22? Servlet是Sun公司制定的一套技术标准，包含与Web应用相关的一系列接口，是Web应用实现方式的宏观解决方案。而具体的Servlet容器负责提供标准的实现。 Servlet作为服务器端的一个组件，它的本意是“服务器端的小程序”。Servlet的实例对象由Servlet容器负责创建；Servlet的方法由容器在特定情况下调用；Servlet容器会在Web应用卸载时销毁Servlet对象的实例。 简单可以理解为 Servlet就是用来处理客户端的请求的. Servlet使用如下1. 源代码使用 src/ 下创建一个类,继承 Servlet,创建步骤如下: 编辑刚创建生成的 HelloServlet.java 文件,编辑service方法,因为此方法是用来处理请求及用户响应的方法编辑完后,Servlet会对 &lt;url-pattern&gt; 中映射的地址提供服务 项目上右键,选择 Run As -&gt; Run On Server 打开的浏览器后拼接 &lt;url-pattern&gt; 中映射的地址 TestUrl,回车访问,eclipse的Console视图出现我们事先声明打印的 “请求已收到….” 提示文字,同时浏览器即出现servlet提供的响应”Response Success!”,至此,基础的使用servlet就完成了. 2. 直接 new servlet 使用如果new的时候没有servlet选项,则使用如下方式添加servlet即可创建的java文件如下同时自动注册Servelet即可对url-pattern中映射的地址提供服务.","tags":[{"name":"JavaWEB","slug":"JavaWEB","permalink":"https://github.com/Y-Cwei/Y-Cwei.github.io/tree/master/tags/JavaWEB/"}]},{"title":"vue+webpack打包上线配置修改","date":"2019-09-05T02:32:57.000Z","path":"2019/09/05/vue-webpack打包上线配置修改/","text":"1. 打包后的项目运行空白问题打包上线后，访问页面，发现页面空白，因为我们部署的时候，我们项目在服务器的相对目录上，二打包后生成的文件，资源为根目录，故而找不到文件， config/index.js 做如下调整即可： // 修改 assetsPublicPath 的值 &apos;/&apos; -&gt; &apos;./&apos; assetsPublicPath: &apos;./&apos;, // 修改前为 assetsPublicPath: &apos;/&apos;, // 修改 productionSourceMap 的值 true -&gt; false productionSourceMap: false, // 修改前为 productionSourceMap: true, 修改结果如图: 2. css中使用 background: url() 引入图片不显示打包上线后，css中使用background: url() 引入的图片路径错误，不显示，调整 build/utils.js 文件如下： // 修改前 return ExtractTextPlugin.extract({ use: loaders, fallback: &apos;vue-style-loader&apos; }) // 修改后 return ExtractTextPlugin.extract({ use: loaders, fallback: &apos;vue-style-loader&apos;, publicPath: &apos;../../&apos; // 新增背景图片阈值 }) 修改后： 3. 打包上线配置修改完毕，执行 npm run build 对项目进行上线前打包处理，当执行npm run build后，会在项目根目录生成一个dist文件，dist目录内文件为打包上线的最终文件。 注： 当 npm run build 命令执行完毕，会有一个如下的tip提示：该tip意在告诉开发人员，打包生成的文件，要放到服务器上才能正常访问，无法直接通过浏览器来访问打包后的页面，若想自行测试，可通过node中的express来测试打包项目是否正常！ 4. express如何测试打包文件 npm i express –g ,执行当前命令，会下载最新版express4.0版本，该版本已将express的命令工具分离，还需下载安装对应的命令工具，键入:npm i express-generator –g 下载，或 npm i express@版本号 -g 下载低版本express即可。 下载完成，使用express创建一个工程： express yourprojectname(自定义项目名) 进入项目主目录： cd yourprojectname 下载安装所需依赖： npm install 启动程序： npm start 注： 当命令行出现 node ./bin/www 证明程序已经开始启动，稍等不报错即可通过 http://localhost:3000 来访问当前项目public目录下的index.html文件，但开发者似无感知，可通过修改bin/www文件来给开发者一个成功启动程序的日志提示，修改方式如下： // server.listen(port); server.listen(port,function(){ console.log(&apos;Your application is running here: http://localhost:&apos;+port); }); 修改完成，当执行npm start程序启动成功后，控制台会打印输出 Your application is running here: http://localhost:3000 ，表明程序启动成功。 将打包好的dist文件，拷贝到此项目public目录下，启动程序，通过： http://localhost:3000/dist 即可访问打包的文件，可自测打包文件是否完整。","tags":[{"name":"vue","slug":"vue","permalink":"https://github.com/Y-Cwei/Y-Cwei.github.io/tree/master/tags/vue/"}]},{"title":"JDBC","date":"2019-09-04T08:49:40.000Z","path":"2019/09/04/JDBC/","text":"1. 概述在Java中，数据库存取技术可分为如下几类： JDBC直接访问数据库 JDO技术（Java Data Object） 第三方O/R工具，如Hibernate, Mybatis 等 JDBC是java访问数据库的基石，JDO, Hibernate等只是更好的封装了JDBC。 1. 什么是JDBC？JDBC(Java Database Connectivity)是一个独立于特定数据库管理系统（DBMS）、通用的SQL数据库存取和操作的公共接口（一组API），定义了用来访问数据库的标准Java类库，使用这个类库可以以一种标准的方法、方便地访问数据库资源JDBC为访问不同的数据库提供了一种统一的途径 ，为开发者屏蔽了一些细节问题。JDBC的目标是使Java程序员使用JDBC可以连接任何提供了JDBC驱动程序的数据库系统，这样就使得程序员无需对特定的数据库系统的特点有过多的了解，从而大大简化和加快了开发过程。如果没有JDBC，那么Java程序访问数据库时是这样的：使用JDBC后，Java程序访问数据库时就变成了如下形式： 结论：JDBC是SUN公司提供一套用于数据库操作的接口API，Java程序员只需要面向这套接口编程即可。不同的数据库厂商，需要针对这套接口，提供不同实现。不同的实现的集合，即为不同数据库的驱动。 2. JDBC APIJDBC API是一系列的接口，它统一和规范了应用程序与数据库的连接、执行SQL语句，并到得到返回结果等各类操作。声明在java.sql与javax.sql包中。 3. JDBC程序编写步骤 注册驱动（加载驱动） 获取连接对象 获取命令对象 编写sql语句 执行sql语句 获取结果集 处理结果 释放资源 如图所示： 3.1 导入jdbc的jar包驱动程序由数据库提供商提供下载。 点击下载MySQL的驱动下载 新建lib文件夹,用于存放第三方jar包,将 mysql-connector-java-5.1.44-bin.jar jar包粘贴到新建的lib文件夹内 选中lib文件夹下的 mysql-connector-java-5.1.44-bin.jar包, 右键 Build Path -&gt; Add to Build Path(因为已经创建过,所以此处无 Add to Build Path 按钮) 此时根目录下会自动生成一个 Referenced Libraries 目录,内含有小奶瓶状的 mysql-connector-java-5.1.44-bin.jar包,即代表导入成功 准备工作完成,使用jdbc连接操作数据库. 3.2 使用jdbc查询数据库数据 3.3 使用jdbc向数据库中添加数据 3.4 使用jdbc向数据库中删除数据 3.5 使用jdbc修改数据库中的数据 注意: excute返回值问题boolean execute() throws SQLException在此 PreparedStatement 对象中执行 SQL 语句，该语句可以是任何种类的 SQL 语句。一些特别处理过的语句返回多个结果，execute 方法处理这些复杂的语句；executeQuery 和 executeUpdate 处理形式更简单的语句。 execute 方法返回一个 boolean 值，以指示第一个结果的形式。必须调用 getResultSet 或 getUpdateCount 方法来检索结果，并且必须调用 getMoreResults 移动到任何后面的结果返回：如果第一个结果是 ResultSet 对象，则返回 true；如果第一个结果是更新计数或者没有结果，则返回 false，意思就是如果是查询的话返回true，如果是更新或插入的话就返回false了；execute()返回的是一个boolean值,代表两种不同的操作啊,getResultSet()返回的是结果集,而getUpdateCount()返回的是更新的记数。 2.JDBC中数据库连接池的使用1. 数据库连接池的必要性不使用数据库连接池存在的问题: 普通的JDBC数据库连接使用 DriverManager 来获取，每次向数据库建立连接的时候都要将 Connection 加载到内存中，再验证IP地址，用户名和密码(得花费0.05s～1s的时间)。需要数据库连接的时候，就向数据库要求一个，执行完成后再断开连接。这样的方式将会消耗大量的资源和时间。数据库的连接资源并没有得到很好的重复利用.若同时有几百人甚至几千人在线，频繁的进行数据库连接操作将占用很多的系统资源，严重的甚至会造成服务器的崩溃。 对于每一次数据库连接，使用完后都得断开。否则，如果程序出现异常而未能关闭，将会导致数据库系统中的内存泄漏，最终将导致重启数据库。 这种开发不能控制被创建的连接对象数，系统资源会被毫无顾及的分配出去，如连接过多，也可能导致内存泄漏，服务器崩溃。为解决传统开发中的数据库连接问题，可以采用数据库连接池技术（connection pool）。 数据库连接池的基本思想就是为数据库连接建立一个“缓冲池”。预先在缓冲池中放入一定数量的连接，当需要建立数据库连接时，只需从“缓冲池”中取出一个，使用完毕之后再放回去。数据库连接池负责分配、管理和释放数据库连接，它允许应用程序重复使用一个现有的数据库连接，而不是重新建立一个。连接池的最大数据库连接数量限定了这个连接池能占有的最大连接数，当应用程序向连接池请求的连接数超过最大连接数量时，这些请求将被加入到等待队列中。 数据库连接池技术的优点： 资源重用 由于数据库连接得以重用，避免了频繁创建，释放连接引起的大量性能开销。在减少系统消耗的基础上，另一方面也增加了系统运行环境的平稳性。 更快的系统反应速度 数据库连接池在初始化过程中，往往已经创建了若干数据库连接置于连接池中备用。此时连接的初始化工作均已完成。对于业务请求处理而言，直接利用现有可用连接，避免了数据库连接初始化和释放过程的时间开销，从而减少了系统的响应时间 新的资源分配手段 对于多应用共享同一数据库的系统而言，可在应用层通过数据库连接池的配置，实现某一应用最大可用数据库连接数的限制，避免某一应用独占所有的数据库资源 统一的连接管理，避免数据库连接泄露 在较为完善的数据库连接池实现中，可根据预先的占用超时设定，强制回收被占用连接，从而避免了常规数据库连接操作中可能出现的资源泄露 2. 多种开源的数据库连接池JDBC 的数据库连接池使用 javax.sql.DataSource 来表示，DataSource 只是一个接口，该接口通常由服务器(Weblogic, WebSphere, Tomcat)提供实现，也有一些开源组织提供实现： DBCP 是Apache提供的数据库连接池，速度相对c3p0较快，但因自身存在BUG，Hibernate3已不再提供支持 C3P0 是一个开源组织提供的一个数据库连接池，速度相对较慢，稳定性还可以 Proxool 是sourceforge下的一个开源项目数据库连接池，有监控连接池状态的功能，稳定性较c3p0差一点 BoneCP 是一个开源组织提供的数据库连接池，速度快 Druid 是阿里提供的数据库连接池，据说是集DBCP 、C3P0 、Proxool 优点于一身的数据库连接池，但是速度不知道是否有BoneCP快 DataSource 通常被称为数据源，它包含连接池和连接池管理两个部分，习惯上也经常把 DataSource 称为连接池注意： 数据源和数据库连接不同，数据源无需创建多个，它是产生数据库连接的工厂，因此整个应用只需要一个数据源即可。 当数据库访问结束后，程序还是像以前一样关闭数据库连接：conn.close(); 但conn.close()并没有关闭数据库的物理连接，它仅仅把数据库连接释放，归还给了数据库连接池。 3.Druid（德鲁伊）数据源 Druid是阿里巴巴开源平台上一个数据库连接池实现，它结合了C3P0、DBCP、Proxool等DB池的优点，同时加入了日志监控，可以很好的监控DB池连接和SQL的执行情况，可以说是针对监控而生的DB连接池，据说是目前最好的连接池。 4.使用Druid连接池4.1 导入Druid的jar包 4.2 使用Druid连接池4.2.1 代码配置连接 4.2.2 使用 druid.properties 配置文件 src/ 下新建 druid.properties 文件,内容为 使用配置文件连接池连接数据库 4.2.3 提取连接数据库的方法使用druid,每次连接数据库,都要重复一下步骤: 加载properties配置文件 加载驱动 从连接池中获取数据源对象 获取连接对象 关闭连接五个步骤,故可将此部分复用代码提取到一个工具类中,便于复用 提取方法: src/ 下新建一个名为utils的 Java Project 项目,用于存放工具类方法; new Class JDBCUtils 工具类,代码如下: package com.richinfo.team.utils; /** * 工具类: * 获取连接对象 */ import java.io.IOException; import java.io.InputStream; import java.sql.Connection; import java.sql.ResultSet; import java.sql.SQLException; import java.sql.Statement; import java.util.Properties; import javax.sql.DataSource; import com.alibaba.druid.pool.DruidDataSourceFactory; public class JDBCUtils { static DataSource dataSource; static { try { // 1. 加载配置文件 Properties properties = new Properties(); InputStream inputStream = JDBCUtils.class.getClassLoader().getResourceAsStream(&quot;druid.properties&quot;); properties.load(inputStream); // 2. 加载驱动 String driver = properties.getProperty(&quot;driver&quot;); Class.forName(driver); // 3. 获取数据源对象 dataSource = DruidDataSourceFactory.createDataSource(properties); } catch (Exception e) { // TODO Auto-generated catch block e.printStackTrace(); } } // 获取连接对象 public static Connection getConnection() throws SQLException { return dataSource.getConnection(); } // 释放资源 public static void close(ResultSet resultSet,Statement statement, Connection connection) { if (resultSet != null) { try { resultSet.close(); } catch (SQLException e) { // TODO Auto-generated catch block e.printStackTrace(); } } if (statement != null) { try { statement.close(); } catch (SQLException e) { // TODO Auto-generated catch block e.printStackTrace(); } } if (connection != null) { try { connection.close(); } catch (SQLException e) { // TODO Auto-generated catch block e.printStackTrace(); } } } } 封装好工具类后即可通过工具类获取连接对象 新建 JdbcByUtils 测试类,代码如下: package com.rinchinfo.team.moa; import static org.junit.Assert.*; import java.sql.Connection; import java.sql.ResultSet; import java.sql.Statement; import org.junit.Test; import com.richinfo.team.utils.JDBCUtils; public class DruidByUtils { @Test public void testInsert() throws Exception { // 1. 从JDBCUtils工具类里获取连接对象 Connection connection = JDBCUtils.getConnection(); // 2. 创建命令对象 Statement statement = connection.createStatement(); // 3.1 编写sql语句 String insertSql = &quot;insert into account (uname, pwd) values (&apos;旺旺&apos;, &apos;pwd@999&apos;),(&apos;Tom&apos;, &apos;pwd@888&apos;)&quot;; // 4.1 执行sql语句,获取结果集 int resultSet = statement.executeUpdate(insertSql); if (resultSet != 0) { System.out.println(&quot;插入成功!&quot;); } else { System.out.println(&quot;TMD,插入失败了...&quot;); } // 3.2 编写查询的sql语句 String selectQuery = &quot;select * from account&quot;; // 4.2 执行sql语句,获取结果集 ResultSet resultSet1 = statement.executeQuery(selectQuery); while (resultSet1.next()) { String unameString = resultSet1.getString(&quot;uname&quot;); String pwdString = resultSet1.getString(&quot;pwd&quot;); System.out.println(&quot;姓名: &quot;+unameString+&quot;\\t&quot;+&quot;密码: &quot;+pwdString); } // 5. 关闭连接 JDBCUtils.close(resultSet1, statement, connection); } } 输出结果如下: 插入成功! 姓名: 小明 密码: pwd@54321 姓名: 小红 密码: pwd@112222222 姓名: 旺旺 密码: pwd@999 姓名: Tom 密码: pwd@888 4.3 案例:实现登录功能package com.rinchinfo.team.moa; import static org.junit.Assert.*; import java.sql.Connection; import java.sql.ResultSet; import java.sql.Statement; import java.util.Scanner; import org.junit.Test; import com.richinfo.team.utils.JDBCUtils; public class LoginTest { @Test public void login() throws Exception { // 获取用户输入 Scanner scanner = new Scanner(System.in); System.out.println(&quot;请输入用户名&quot;); String uname = scanner.nextLine(); System.out.println(&quot;请输入密码&quot;); String upwd = scanner.nextLine(); Connection connection = null; Statement statement = null; ResultSet resultSet = null; try { connection = JDBCUtils.getConnection(); statement = connection.createStatement(); String loginSqlString = &quot;select * from account where uname=&apos;&quot;+ uname +&quot;&apos; and pwd=&apos;&quot;+ upwd +&quot;&apos;&quot;; resultSet = statement.executeQuery(loginSqlString); if (resultSet.next()) { System.out.println(&quot;登录成功!&quot;); } else { System.out.println(&quot;登录失败!&quot;); } } catch (Exception e) { // TODO: handle exception e.printStackTrace(); } finally { // TODO: handle finally clause JDBCUtils.close(resultSet, statement, connection); } } } 4.4 sql注入场景 SQL注入SQL 注入是利用某些系统没有对用户输入的数据进行充分的检查，而在用户输入数据中注入非法的 SQL 语句段或命令，从而利用系统的 SQL 引擎完成恶意行为的做法。对于 Java 而言，要防范 SQL 注入，只要用 PreparedStatement 取代 Statement 就可以了。 如上登录场景,因为我们无法控制用户的输入,当用户输入如下用户名时依然能登录成功,分析拼接的sql语句为: select * from account where uname=&quot;xxx&quot; or 1=1 #&quot; and pwd=&quot;ssssssss&quot; 此条sql语句因为有 or 1=1 为 true 的存在,所以会将数据库中的数据都查询出来,如图:故无论密码如何输入,均能登录成功; 4.5 使用PreparedStatement防止sql注入PreparedStatement概述可以通过调用 Connection 对象的 preparedStatement(String sql) 方法获取 PreparedStatement 对象PreparedStatement 接口是 Statement 的子接口，它表示一条预编译过的 SQL 语句 PreparedStatement 对象所代表的 SQL 语句中的参数用问号(?)来表示，调用 PreparedStatement 对象的 setXxx() 方法来设置这些参数. setXxx() 方法有两个参数，第一个参数是要设置的 SQL 语句中的参数的索引(从 1 开始)，第二个是设置的 SQL 语句中的参数的值 ResultSet executeQuery()执行查询，并返回该查询生成的 ResultSet 对象。 int executeUpdate()：执行更新，包括增、删、该 用法如下: @Test public void prepareLogin() throws Exception { // 获取用户输入 Scanner scanner = new Scanner(System.in); System.out.println(&quot;请输入用户名&quot;); String uname = scanner.nextLine(); System.out.println(&quot;请输入密码&quot;); String upwd = scanner.nextLine(); Connection connection = null; PreparedStatement statement = null; ResultSet resultSet = null; try { connection = JDBCUtils.getConnection(); // 使用PreparedStatement // statement = connection.createStatement(); // String loginSqlString = &quot;select * from account where uname=&apos;&quot;+ uname +&quot;&apos; and pwd=&apos;&quot;+ upwd +&quot;&apos;&quot;; statement = connection.prepareStatement(&quot;select * from account where uname = ? and pwd = ?&quot;); // 赋值 // 第一个参数为第一个?的位置,第二个参数为?占位符的实参,遇到特殊字符会转译, // 会将第二个参数全部赋值给对应形参,如 xxx&apos; or 1=1 # 会全部当作用户名处理,不会出现sql注入的情况 statement.setString(1, uname); statement.setString(2, upwd); resultSet = statement.executeQuery(); if (resultSet.next()) { System.out.println(&quot;登录成功!&quot;); } else { System.out.println(&quot;登录失败!&quot;); } } catch (Exception e) { // TODO: handle exception e.printStackTrace(); } finally { // TODO: handle finally clause JDBCUtils.close(resultSet, statement, connection); } } 登录结果为: 3. 批量处理使用场景:当一次性插入很多条数据时,可以使用批量处理好处:减少执行次数,提高执行效率常用方法:addBatch();executeBatch();clearBatch();如场景,一次性插入5000条数据,代码如下: @Test public void prepareLogin() throws Exception { // 获取用户输入 Scanner scanner = new Scanner(System.in); System.out.println(&quot;请输入用户名&quot;); String uname = scanner.nextLine(); System.out.println(&quot;请输入密码&quot;); String upwd = scanner.nextLine(); Connection connection = null; PreparedStatement statement = null; ResultSet resultSet = null; try { connection = JDBCUtils.getConnection(); statement = connection.prepareStatement(&quot;select * from account where uname = ? and pwd = ?&quot;); for (int i=1; i&lt;=5000; i++) { statement.setString(1, uname); statement.setString(2, upwd); // 将sql语句添加到批量处理中 statement.addBatch(); if (i%1000==0) { // 执行批量处理 statement.executeBatch(); // 清空批量处理中的语句 statement.clearBatch(); } } if (resultSet.next()) { System.out.println(&quot;登录成功!&quot;); } else { System.out.println(&quot;登录失败!&quot;); } } catch (Exception e) { // TODO: handle exception e.printStackTrace(); } finally { // TODO: handle finally clause JDBCUtils.close(resultSet, statement, connection); } } 事物@Test public void test(){ Connection connection = null; PreparedStatement statement = null; try { connection = JDBCUtils.getConnection(); // 设置自动提交为false 手动开启事务 connection.setAutoCommit(false); statement = connection.prepareStatement(&quot;update accout set money = ? where uname = ?&quot;); statement.setDouble(1, 500); statement.setString(2, &quot;小明&quot;); statement.executeUpdate(); statement.setDouble(1, 1500); statement.setString(2, &quot;大明&quot;); statement.executeUpdate(); // 提交事务 connection.commit(); } catch (SQLException e) { // TODO Auto-generated catch block e.printStackTrace(); try { // 如果出新问题,回滚代码 connection.rollback(); } catch (SQLException e1) { // TODO Auto-generated catch block e1.printStackTrace(); } }finally { JDBCUtils.close(null, statement, connection); } }","tags":[{"name":"JDBC","slug":"JDBC","permalink":"https://github.com/Y-Cwei/Y-Cwei.github.io/tree/master/tags/JDBC/"}]},{"title":"mysql之事务","date":"2019-09-04T06:55:11.000Z","path":"2019/09/04/mysql之事务/","text":"事务事务属于 DTL 控制语言 1. 什么是事务？为什么要用事务？ 一个事务由一条或者多条sql语句构成，这一条或者多条sql语句要么全部执行成功，要么全部执行失败！ 默认情况下，每条单独的sql语句就是一个单独的事务！ 2. 事务的四大特性（ACID）？ 原子性（Atomicity）：事务中所有操作是不可再分割的原子单位。事务中所有操作要么全部执行成功，要么全部执行失败。 一致性（Consistency）：事务执行后，数据库状态与其它业务规则保持一致。如转账业务，无论事务执行成功与否，参与转账的两个账号余额之和应该是不变的。 隔离性（Isolation）：隔离性是指在并发操作中，不同事务之间应该隔离开来，使每个并发中的事务不会相互干扰。 持久性（Durability）：一旦事务提交成功，事务中所有的数据操作都必须被持久化到数据库中，即使提交事务后，数据库马上崩溃，在数据库重启时，也必须能保证通过某种机制恢复数据。 2.1 用法演示# 创建 db2 数据库 CREATE DATABASE IF NOT EXISTS db2; # 使用 db2 USE db2; # 查看使用的表 SELECT DATABASE(); # 创建 account 表 CREATE TABLE IF NOT EXISTS account( id INT PRIMARY KEY AUTO_INCREMENT, uname VARCHAR(16), pw VARCHAR(16), money DECIMAL(9,2) ); # 插入数据 INSERT INTO account(uname, pw, money) VALUES(&apos;小琪&apos;, &apos;pwd12345&apos;, 2000), (&apos;小洪&apos;, &apos;pwd12345&apos;, 5000); # 查看插入结果 SELECT id AS 序号, uname 姓名, pw 密码, money 存款 from account; # 输出结果如下 +----+-------+----------+---------+ | id | uname | pw | money | +----+-------+----------+---------+ | 1 | 小琪 | pwd12345 | 2000.00 | | 2 | 小洪 | pwd12345 | 5000.00 | +----+-------+----------+---------+ 2 rows in set (0.03 sec) 场景描述： 假如小琪想要给小洪转账1000元钱，代码描述如下 # 1. 小琪账户减少1000元钱 UPDATE account SET money=money-1000 WHERE uname=&apos;小琪&apos;; # 2. 小洪账户增加1000元钱 UPDATE account SET money=money+1000 WHERE uname=&apos;小洪&apos;; # 查看转账结果 SELECT id AS 序号, uname 姓名, pw 密码, money 存款 from account; # 输出结果如下 +----+-------+----------+---------+ | id | uname | pw | money | +----+-------+----------+---------+ | 1 | 小琪 | pwd12345 | 1000.00 | | 2 | 小洪 | pwd12345 | 6000.00 | +----+-------+----------+---------+ 2 rows in set (0.03 sec) 3. 事务的使用步骤：如果在转账过程中，小琪账户减少了1000元钱，但是由于网络或者其它因素所致，小洪并没有收到小琪的转账1000元钱，违背了事务四大特性的一致性，所以必须要使用事务，来保证事务的一致性，事务使用如下： # 1. 开启事务 START TRANSACTION; # 2. 编写事务的sql语句（增删改） UPDATE DELETE INSERT SELECT会自动提交数据 UPDATE account SET money=money-1000 WHERE uname=&apos;小琪&apos;; UPDATE account SET money=money+1000 WHERE uname=&apos;小洪&apos;; # 3. 提交事务（无错误信息时）/ 回滚事务（又错误信息时） # ROLLBACK; # 回滚事务 COMMIT; # 提交事务 使用事务，能很好的保证事务的一致性，有突发事件可以通过 ROLLBACK 回滚到初始状态； 小技巧： # 查看当前数据库是否开启自动提交事务 SHOW VARIABLES LIKE &apos;autocommit&apos;; # autocommit ON # 关闭自动提交事务 SET autocommit=0; # 查看当前数据库是否开启自动提交事务 SHOW VARIABLES LIKE &apos;autocommit&apos;; # autocommit OFF # 重新开启自动提交事务 SET autocommit=1; # 查看当前数据库是否开启自动提交事务 SHOW VARIABLES LIKE &apos;autocommit&apos;; # autocommit ON","tags":[{"name":"mysql","slug":"mysql","permalink":"https://github.com/Y-Cwei/Y-Cwei.github.io/tree/master/tags/mysql/"}]},{"title":"mysql基础语法","date":"2019-09-03T09:32:15.000Z","path":"2019/09/03/mysql基础语法/","text":"SQL语句分类 DDL(Data Definition Language):数据定义语言，用来定义数据库对象：库、表、列等。功能：创建、删除、修改库和表结构。 DML(Data Manipulation Language):数据操作语言，用来定义数据库记录:增、删、改表记录。 DCL(Data Control Language):数据控制语言，用来定义访问权限和安全级别。 DQL(Data Query Language):数据查询语言，用来查询记录。也是本章学习的重点。 SQL数据中的属性类型 TINYINT:1字节，小整数值。 SMALLINT:2字节，大整数值。 MEDIUMINT:3字节，大整数值。 INT或INTEGER:4字节，整型,大整数值。 FLOAT:单精度浮点数值。 DOUBLE(5,2):双精度浮点型数值，参数表示该浮点型数值最多有5位，其中必须有2位小数。 DECIMAL(M,D):小数值,参数表示该数值最多有M位，其中必须有D位小数。 CHAR:字符型，固定长度字符串类型:char(255)。你存入一个a字符，虽然a只占一个字符，但是它会自动给你加254个空格凑成255个长度。即数据的长度不足指定长度，它会补足到指定长度。 VARCHAR:可变长度字符串类型：- varchar(65535),你存入的数据多长它就是多长。它会抽出几个字节来记录数据的长度。 TEXT(CLOB):mysql独有的数据类型，字符串类型。 BLOB:字节类型。 YEAR:年份值，格式为:YYYY DATA:日期类型，格式为:yyyy-MM-dd。 TIME:时间类型，格式为:hh:mm:ss。 TIMESTAMP:时间戳类型，格式为上面二者的综合。 DATETIME:混合日期和时间值，格式为:YYYYMMDD HHMMSS. SQL语句详解 当然首先需要再命令行中输入mysql -uroot -p来进入mysql。 注意: MySQL语法不区分大小写，但是建议在写关键字时用大写。 每一条语句后面以分号结尾。 mysql用户管理： 首先登录到MySQL mysql -u root -p 远程登录服务 [root@lear user1]# mysql -h10.211.55.16 -P3306 -uclass -p Enter password: Welcome to the MySQL monitor. Commands end with ; or \\g. Your MySQL connection id is 5 Server version: 5.1.73 Source distribution 数据库 查看数据库 show databases; mysql&gt; show databases; +--------------------+ | Database | +--------------------+ | information_schema | | mysql | | test | +--------------------+ 3 rows in set (0.00 sec) mysql&gt; 查看当前的数据库 select database(); 进入数据库 use mysql;如果不使用数据库，则当前的数据库为空NULL，use之后，数据库不为空。 mysql&gt; select database(); +------------+ | database() | +------------+ | NULL | +------------+ 1 row in set (0.00 sec) mysql&gt; use mysql; Reading table information for completion of table and column names You can turn off this feature to get a quicker startup with -A Database changed mysql&gt; select database(); +------------+ | database() | +------------+ | mysql | +------------+ 1 row in set (0.00 sec) mysql&gt; 创建数据库 create database [if not exists] database_name;如果数据库存在，创建会报错，加一个判断，当数据库不存在的时候再创建 ysql&gt; create database if not exists mydb; Query OK, 1 row affected, 1 warning (0.00 sec) mysql&gt; show databases; +--------------------+ | Database | +--------------------+ | information_schema | | mydb | | mysql | | test | +--------------------+ 4 rows in set (0.00 sec) mysql&gt; 删除数据库 drop database if exists database_name; mysql&gt; show databases; +--------------------+ | Database | +--------------------+ | information_schema | | mydb | | mysql | | test | +--------------------+ 4 rows in set (0.00 sec) mysql&gt; create database if not exists temp; Query OK, 1 row affected (0.00 sec) mysql&gt; show databases; +--------------------+ | Database | +--------------------+ | information_schema | | mydb | | mysql | | temp | | test | +--------------------+ 5 rows in set (0.00 sec) mysql&gt; drop database if exists temp; Query OK, 0 rows affected (0.00 sec) mysql&gt; show databases; +--------------------+ | Database | +--------------------+ | information_schema | | mydb | | mysql | | test | +--------------------+ 4 rows in set (0.00 sec) mysql&gt; 数据表 显示数据库表 show tables;默认显示当前数据库的表show tables from mysql; 查看 mysql 指定数据库的表 mysql&gt; use mydb; Reading table information for completion of table and column names You can turn off this feature to get a quicker startup with -A Database changed mysql&gt; show tables; +----------------+ | Tables_in_mydb | +----------------+ | tb1 | +----------------+ 1 row in set (0.00 sec) mysql&gt; show tables from mysql; +---------------------------+ | Tables_in_mysql | +---------------------------+ | columns_priv | | db | | event | | func | | general_log | | help_category | | help_keyword | | help_relation | | help_topic | | host | | ndb_binlog_index | | plugin | | proc | | procs_priv | | servers | | slow_log | | tables_priv | | time_zone | | time_zone_leap_second | | time_zone_name | | time_zone_transition | | time_zone_transition_type | | user | +---------------------------+ 23 rows in set (0.00 sec) mysql&gt; 创建数据表INT 整数类型VARCHAR 变长字符，参数为最大字符限制 mysql&gt; create table tb1( -&gt; id INT, -&gt; name VARCHAR(20) -&gt; ); Query OK, 0 rows affected (0.02 sec) mysql&gt; 删除数据表 drop table (table_name); 查看表信息 show create table (table_name) [\\G]; mysql&gt; show create table tb1 \\G *************************** 1. row *************************** Table: tb1 Create Table: CREATE TABLE tb1 ( id int(11) DEFAULT NULL, name varchar(20) DEFAULT NULL ) ENGINE=MyISAM DEFAULT CHARSET=utf8 1 row in set (0.00 sec) mysql&gt; 查看表结构 describe (table_name); 或者 show columns from tb1; mysql&gt; describe tb1; +-------+-------------+------+-----+---------+-------+ | Field | Type | Null | Key | Default | Extra | +-------+-------------+------+-----+---------+-------+ | id | int(11) | YES | | NULL | | | name | varchar(20) | YES | | NULL | | +-------+-------------+------+-----+---------+-------+ 2 rows in set (0.00 sec) mysql&gt; 修改表结构 alter table tb1 add age INT; mysql&gt; alter table tb1 add age INT; Query OK, 0 rows affected (0.02 sec) Records: 0 Duplicates: 0 Warnings: 0 mysql&gt; desc tb1; +-------+-------------+------+-----+---------+-------+ | Field | Type | Null | Key | Default | Extra | +-------+-------------+------+-----+---------+-------+ | id | int(11) | YES | | NULL | | | name | varchar(20) | YES | | NULL | | | age | int(11) | YES | | NULL | | +-------+-------------+------+-----+---------+-------+ 3 rows in set (0.00 sec) mysql&gt; 修改表名称 alter table table1 rename to teacher; 修改列名称 alter table table1 change name user_name varchar(10) not null;指定位置添加 mysql&gt; alter table tb1 add gender char(1) after name; Query OK, 0 rows affected (0.02 sec) Records: 0 Duplicates: 0 Warnings: 0 mysql&gt; desc tb1; +--------+-------------+------+-----+---------+-------+ | Field | Type | Null | Key | Default | Extra | +--------+-------------+------+-----+---------+-------+ | id | int(11) | YES | | NULL | | | name | varchar(20) | YES | | NULL | | | gender | char(1) | YES | | NULL | | | age | int(11) | YES | | NULL | | +--------+-------------+------+-----+---------+-------+ 4 rows in set (0.00 sec) mysql&gt; 添加多列 mysql&gt; alter table tb1 add(aaa int, bb int, cc int); Query OK, 0 rows affected (0.01 sec) Records: 0 Duplicates: 0 Warnings: 0 mysql&gt; desc tb1; +--------+-------------+------+-----+---------+-------+ | Field | Type | Null | Key | Default | Extra | +--------+-------------+------+-----+---------+-------+ | id | int(11) | YES | | NULL | | | name | varchar(20) | YES | | NULL | | | gender | char(1) | YES | | NULL | | | age | int(11) | YES | | NULL | | | aaa | int(11) | YES | | NULL | | | bb | int(11) | YES | | NULL | | | cc | int(11) | YES | | NULL | | +--------+-------------+------+-----+---------+-------+ 7 rows in set (0.00 sec) mysql&gt; 删除数据表结构 alter table (table_name) drop &#39;(column_name)&#39;; mysql&gt; alter table tb1 drop aa; ERROR 1091 (42000): Can&apos;t DROP &apos;aa&apos;; check that column/key exists mysql&gt; alter table tb1 drop aaa; Query OK, 0 rows affected (0.00 sec) Records: 0 Duplicates: 0 Warnings: 0 mysql&gt; desc tb1; +--------+-------------+------+-----+---------+-------+ | Field | Type | Null | Key | Default | Extra | +--------+-------------+------+-----+---------+-------+ | id | int(11) | YES | | NULL | | | name | varchar(20) | YES | | NULL | | | gender | char(1) | YES | | NULL | | | age | int(11) | YES | | NULL | | | bb | int(11) | YES | | NULL | | | cc | int(11) | YES | | NULL | | +--------+-------------+------+-----+---------+-------+ 6 rows in set (0.00 sec) mysql&gt; 删除多列 alter table (table_name) drop bb,drop cc; mysql&gt; alter table tb1 drop bb,drop cc; Query OK, 0 rows affected (0.01 sec) Records: 0 Duplicates: 0 Warnings: 0 mysql&gt; desc tb1; +--------+-------------+------+-----+---------+-------+ | Field | Type | Null | Key | Default | Extra | +--------+-------------+------+-----+---------+-------+ | id | int(11) | YES | | NULL | | | name | varchar(20) | YES | | NULL | | | gender | char(1) | YES | | NULL | | | age | int(11) | YES | | NULL | | +--------+-------------+------+-----+---------+-------+ 4 rows in set (0.00 sec) 向数据表中添加数据 insert [INTO] (table_name) (column1,column2) values (value1,value2) mysql&gt; insert into tb1 values(1,&apos;rose&apos;,&apos;m&apos;,18); Query OK, 1 row affected (0.00 sec) 一次添加多行数据 mysql&gt; insert into tb1 (id,name) values (2,&apos;zhangsan&apos;),(3,&apos;lisi&apos;); Query OK, 2 rows affected (0.00 sec) Records: 2 Duplicates: 0 Warnings: 0 mysql&gt; select * from tb1; +------+----------+--------+------+ | id | name | gender | age | +------+----------+--------+------+ | 1 | rose | m | 18 | | 2 | zhangsan | NULL | NULL | | 3 | lisi | NULL | NULL | +------+----------+--------+------+ 3 rows in set (0.00 sec) mysql&gt; 通过set添加数据 insert into tb1 name=&apos;zhangsan&apos;,age=30; 更新数据 update tb1 set age=age+1 [where name=&apos;rose&apos;]; 删除数据 delete from tb1 where name=&apos;rose&apos;; 查看数据表中的数据 select * from tb1; 查询指定列 select name from students; 给查询取别名 as是可选 select name as 姓名,s_id 学号 from students; 排序 -- 升序 select * from stu_detail order by age (asc); -- 降序 select * from stu_detail order by age desc; 限制显示的数量 -- 显示前2个 select * from stu_detail limit 2; -- 显示第3个开始的4个数据 select * from stu_detail limit 2,4; 数据分组 select d_id,count(d_id) from students group by d_id; -- 条件分组 select d_id,count(d_id) from students group by d_id having d_id &gt; 3; 也可以使用别名 select d_id as 学院ID,count(d_id) from students group by d_id having 学院ID &gt; 3; 查询结果处理 -- 取最大值 select max(age) from stu_detail; -- 去平均值 select avg(age) from stu_detail; -- 去最小值 select min(age) from stu_detail; 子查询 select * from stu_detail where age &gt; (select avg(age) from stu_detail); 关联查询 select * from students,department where d_id=id; select * from students inner join department where d_id=id; select * from students inner join department on d_id=id; -- 左连接 students的数据都能显示 student d_id没有department对应的，也能显示 不能用where 必需用on select * from students left join department on d_id = id; -- 右连接 department的数据都能显示 select * from students right join department on d_id = id; 事务 关联的SQL语句一起执行 start transaction 开始事务 commit 提交事务 rollback 回滚事务，放弃修改 mysql常见问题1. insert into 插入报错执行 insert into 数据表名 (列1,列2) values(&quot;列1要插入的值&quot;,&quot;列2要插入的值&quot;); 命令,报错,报错信息如下:出现此问题原因为已建立的表无法插入中文字符串使用 show create table 表名 查询创建表信息命令查询可知,表默认的字符编码为latin1字符集,查询结果如下或者使用 show full fields from 表名; 查询表详细信息,查询结果如下:因为数据表中的内容为latin1字符集，查询资料可知，latin1字符集为8bit，这说明它是不能表示中文的，故而当然会报改错： 解决方法如下:修改字段的字符集,将其修改为 utf8 字符集即可;修改字段的字符集语法为 alter table 表名 change 列名 列名 列类型 character set utf8;,如下:如上修改之后,在执行 insert into ... 插入命令即可; 扩展: 修改数据库字符集命令 alter database 数据库名 character set utf8;. 修改数据表字符集命令 alter table 数据表名 character set utl8;","tags":[{"name":"mysql","slug":"mysql","permalink":"https://github.com/Y-Cwei/Y-Cwei.github.io/tree/master/tags/mysql/"}]},{"title":"java基本语法","date":"2019-06-15T14:33:15.000Z","path":"2019/06/15/java基本语法-md/","text":"1. java基本语法1. 标识符规则： 由26个字母大小写，0-9，和 _ 和 $（禁止使用）； 数字不可以开头； 不可以使用关键字和保留字； 严格区分大小写，长度最大65535； 不能使用空格。 2. 命名规范： 包名： 全部小写； 类名： 首字母大写，后面的每个单词的首字母也大写，如 MyClassName（驼峰命名法）； 变量名和方法名： 首字母小写，后面的每个单词首字母大写； 常量名： 全部大写，单词间用 _ 隔开。 3. 变量 作用：用于保存数据。 3.1 变量的概念： 内存中的存储区域； 该区域由自己的名称（变量名）和类型（数据类型）； java中每个变量必须先声明，后使用； 该区域的数据可以在同一类型范围内不断变化； 变量的声明： 数据类型 变量名。 3.2 使用变量需注意： 变量的作用范围，一对 {} 之间的区域；","tags":[{"name":"java","slug":"java","permalink":"https://github.com/Y-Cwei/Y-Cwei.github.io/tree/master/tags/java/"}]},{"title":"java基础入门","date":"2019-06-10T14:03:36.000Z","path":"2019/06/10/java基础-md/","text":"1. JAVA基础介绍1.1 java面向对象编程 面向对象编程的三大特性 封装：继承：多态：（抽象）： java程序要素介绍： java源文件以“.java”为扩展名。源文件的基本组成部分是类（class），如本类中的 PersonInfo 类 一个源文件中最多只能有一个 public 类。其它类的个数不限，如果源文件包含一个 public 类，则文件名必须按该雷鸣命名。 Java应用程序的执行文件入口是 main() 方法。它有固定的书写格式：public static void main(String[] args){…} Java语言严格区分大小写。 Java方法由一条条语句构成，每个语句以“;”结束。 打括号是成对出现的，缺一不可。 /** * public: 公共的，公开的 * class: 类的定义 * PersonInfo: 类名 * 类是java程序最基本的单位 * 类 = 类头（类签名） + 类体 * public class PersonInfo: 类名 * { }: 类体，类后面的一对 {} 及其中的内容 * main: 主方法，程序的入口方法 * 主类: 包含主方法的类就是主类 */ public class PersonInfo { /** * 方法: 完成某种特定功能的单位 * public static: 修饰符 * void: 无返回值 * main: 方法名 * （String[] args）: 参数 * 方法名后面的一对 {} 及其中的内容称为方法体 * 方法 = 方法签名 + 方法体 */ public static void main (String[] args) { /** * 语句: java程序的最小执行单位，语句必须以分号 ; 结尾 */ System.out.println(&quot;姓名： 张三&quot;); System.out.println(&quot;性别： 男&quot;); System.out.println(&quot;籍贯： 河北&quot;); System.out.println(&quot;住址： 河北省保定市&quot;); } } 开发一个java程序的步骤： 在目录下创建一个文本文件，文件名是 公共类名.java，编辑这个文件 命令行下使用 javac 公共类名.java，编译源文件，产生多个.class文件，文件数量取决于 源文件中方法的个素 执行这个程序，java 主类名 执行过程： java 创建JVM 由ClassLoader加载主类 执行主类中的主方法 主方法执行完毕后，销毁JVM.进程结束","tags":[{"name":"JAVA","slug":"JAVA","permalink":"https://github.com/Y-Cwei/Y-Cwei.github.io/tree/master/tags/JAVA/"}]},{"title":"node.js学习笔记之入门","date":"2019-04-15T12:51:35.000Z","path":"2019/04/15/node-js学习笔记之入门-md/","text":"1. Node.js介绍1.1 Node.js是什么？ Node.js® is a JavaScript runtime built on Chrome’s V8 JavaScript engine. node.js 不是一门语言 node.js 不是库，不是框架 node.js 是一个javascript运行时环境 简单来讲，Node.js可以解析和执行js代码 以前只有浏览器可以解析之行javascript代码 也就是说现在的javascript可以完全脱离浏览器来运行，一切都归功于Node.js 构建于 Chrome 的 V8 引擎之上 代码只是具有特定格式的字符串而已 引擎可以认识它，可以帮你去解析和执行 Google Chrome 的 V8 引擎是目前公认解析 JavaScript 最快的 Node.js 之所以很快的原因之一是：Node.js的作者，将Google Chrome 中的 V8 引擎移植了出来，开发了一个独立的 javaScript 运行时环境 Node.js uses an event-driven, non-blockling I/O model that makes it leightweight and efficient event-driven 时间驱动 non-blocking I/O model 非阻塞I/O模型（异步） lightweidht and efficient 轻量和高效 Node.js package ecosystem, npm is the largest ecosystem of open source libraiies in the word npm 是世界上最大的开源生态系统 绝大多数的javascript相关的包都放在了npm上，这样做的目的是让开发人员更方便的去开发使用它 npm install jquery 1.2 浏览器中的js和Node.js中的js的区别 浏览器中的javascript EcmaScript 基本语法 if var function Object Array BOM DOM Node.js中的javascript 没有BOM,DOM(浏览器不操作BOM,DOM) EcmaScript 在Node这个javaScript执行环境中为javaScript提供了一些服务器级别的操作API 例如文件的读写 网络服务的构建 网络通信 http服务器 等的处理…","tags":[{"name":"Node.js","slug":"Node-js","permalink":"https://github.com/Y-Cwei/Y-Cwei.github.io/tree/master/tags/Node-js/"}]},{"title":"vue学习笔记之vuex状态管理","date":"2019-03-28T13:43:36.000Z","path":"2019/03/28/vue学习笔记之vuex状态管理-md/","text":"vue学习笔记之vuex状态管理 vuex用于状态管理，使用如下 1. 项目中引入vuexnpm i vuex -s 1.1 下载安装完成，修改项目src/main.js，引入 vuex imoprt Vuex from &apos;vuex&apos; // 引入Vuexœ Vue.use(Vuex) // 声明使用Vuex","tags":[{"name":"vue","slug":"vue","permalink":"https://github.com/Y-Cwei/Y-Cwei.github.io/tree/master/tags/vue/"},{"name":"vuex","slug":"vuex","permalink":"https://github.com/Y-Cwei/Y-Cwei.github.io/tree/master/tags/vuex/"}]},{"title":"vue-node.md","date":"2019-03-24T14:43:48.000Z","path":"2019/03/24/vue-node-md/","text":"","tags":[{"name":"vue-node","slug":"vue-node","permalink":"https://github.com/Y-Cwei/Y-Cwei.github.io/tree/master/tags/vue-node/"},{"name":"get","slug":"get","permalink":"https://github.com/Y-Cwei/Y-Cwei.github.io/tree/master/tags/get/"},{"name":"post","slug":"post","permalink":"https://github.com/Y-Cwei/Y-Cwei.github.io/tree/master/tags/post/"}]},{"title":"前后端交互之跨域问题","date":"2019-01-11T11:13:13.000Z","path":"2019/01/11/2019-01-11-前后端交互之跨域问题-md/","text":"前后端交互之跨域问题跨域出现的原因：浏览器为安全性考虑而实施的同源策略 ，当协议名，域名，端口号三者中任一一种不相同，就会产生跨域问题。 1. jsonp解决跨域 在 HTML 标签里，一些诸如 script、img 这样的资源的标签是没有跨域限制的，我们利用这一点，绕过 ajax 引擎，从而解决跨域请求 使用 node.js 建立服务 const http = require(&apos;http&apos;); // 导入http内置模块 const server = http.createServer() // 创建一个http服务 server.on(&apos;request&apos;, function(req, res){ // 监听http服务器的request请求 const url = req.url // 获取请求的url if (url === &apos;/xxxxxx&apos;) { var scriptStr = &apos;show()&apos;; // 拼接一个合法的js脚本(前端事先声明好的方法的调用) res.end(scriptStr)； // res.end发送给客户端，客户端去把这个字符串，当作js代码去解析执行 } else { res.end(&apos;404 Not Found!&apos;)； } }) server.listen(3000, function(){ // 指定端口号并启动服务器监听 console.log(&apos;server listen at http://127.0.0.1:3000&apos;)； }) 前端书写规范 &lt;script type=&quot;text/javascript&quot;&gt; function show (data) { // 事先声明好一个处理请求的回调函数，供服务器触发 // 处理请求的逻辑 console.log(data) } &lt;/script&gt; &lt;script src=&quot;http://127.0.0.1:3000/xxxxxx&quot;&gt;&lt;/script&gt; 注意：以上方法，写死了show()方法，不能动态处理请求，升级改造如下： node.js服务升级 const http = require(&apos;http&apos;); const urlModule = require(&apos;url&apos;); // 引入url模块，这个模块能够帮我们解析URL地址，从而拿到 pathname,query const server = http.createServer(); server.on(&apos;request&apos;, function(req, res){ // const url = req.url; // const { pathname, query } = urlModule.parse(req.url, true); // 获取请求的url const { pathname: url, query } = urlModule.parse(req.url, true); // 获取请求的url,并将pathname重命名为url if (url === &apos;/xxxxxx&apos;) { var resData = { // 新增数据对象 name: &apos;xxx&apos;, age: 18 } // var scriptStr = &apos;show()&apos;; var scriptStr = `${query.callback}(${JSON.stringify(resData)})`; // 修改返回值,query.callback就能取到前端callbak对应的函数名 res.end(scriptStr)； } else { res.end(&apos;404 Not Found!&apos;)； } }) server.listen(3000, function(){ console.log(&apos;server listen at http://127.0.0.1:3000&apos;)； }) 前端编码升级 &lt;script type=&quot;text/javascript&quot;&gt; function showInfo (data) { // 事先声明好一个处理请求的回调函数，供服务器触发 // 处理请求的逻辑 console.log(data) } &lt;/script&gt; &lt;script src=&quot;http://127.0.0.1:3000/xxxxxx?callback=showInfo&quot;&gt;&lt;/script&gt; 2. CORS解决跨域详解可参考阮一峰的 跨域资源共享 CORS 详解 服务端设置响应头 Access-Control-Allow-Origin Access-Control-Allow-Origin： http://api.bob.com； // 只允许http://api.bob.com跨域请求 Access-Control-Allow-Origin： *； // 所以的请求都允许跨域请求","tags":[{"name":"js","slug":"js","permalink":"https://github.com/Y-Cwei/Y-Cwei.github.io/tree/master/tags/js/"}]},{"title":"常用js代码片段","date":"2018-02-19T11:13:13.000Z","path":"2018/02/19/2018-02-19-常用代码片段/","text":"常用js代码片段1.获取当前时间（年-月-日 时:分）module.exports = { getNowTime (connector) { // connector 连接符，不传默认为 - if (!connector) connector = &apos;-&apos; const nowTime = new Date() const nowMonth = nowTime.getMonth()+1 &lt; 10 ? &apos;0&apos; + (nowTime.getMonth()+1) : nowTime.getMonth() + 1 const nowDay = nowTime.getDay() &lt; 10 ? &apos;0&apos; + nowTime.getDay() : nowTime.getDay() const nowHours = nowTime.getHours() &lt; 10 ? &apos;0&apos; + nowTime.getHours() : nowTime.getHours() const nowMinute = nowTime.getMinutes() &lt; 10 ? &apos;0&apos; + nowTime.getMinutes() : nowTime.getMinutes() return nowTime.getFullYear() + connector + nowMonth + connector + nowDay + &apos; &apos; + nowHours + &apos;:&apos; + nowMinute } } // 获取结果为： 2018-02-12 17:08 2.向左滑动展示删除按钮功能//向左滑动展示删除会议按钮 function showDeleteWithSlide () { var slideItem = $(&apos;.meetingList&apos;).find(&apos;ul&apos;); var slideStartX=0, slideStartY=0, slideEndX=0, slideEndY=0, slideX=0, slideY=0; slideItem.on(&apos;touchstart&apos;, function (e) { e.stopPropagation(); slideStartX = e.changedTouches[0].clientX; slideStartY = e.changedTouches[0].clientY; }); slideItem.on(&apos;touchmove&apos;, function(e){ e.stopPropagation(); slideEndX = e.changedTouches[0].clientX; slideEndY = e.changedTouches[0].clientY; slideX = slideEndX - slideStartX; slideY = slideEndY - slideStartY; if(Math.abs(slideY) &gt;= Math.abs(slideX)) { //竖向滑动 slideItem.each(function(){ if($(this).hasClass(&apos;show-from-right&apos;)){ $(this).removeClass(&apos;show-from-right&apos;).addClass(&apos;hide-to-right&apos;); if(&apos;meeting_type&apos; == $(this).children(&apos;li:last-child&apos;).attr(&apos;class&apos;) &amp;&amp; $(this).children(&apos;li:last-child&apos;).text()) $(this).children(&apos;li:last-child&apos;).show(); } }) return; //竖向滑动释放默认行为 }; e.preventDefault(); }); slideItem.on(&apos;touchend&apos;, function(e){ e.stopPropagation(); if(slideX&lt;-50){ $(this).removeClass(&apos;hide-to-right&apos;).addClass(&apos;show-from-right&apos;); }else if (slideX&gt;50) { if($(this).hasClass(&apos;show-from-right&apos;)) $(this).removeClass(&apos;show-from-right&apos;).addClass(&apos;hide-to-right&apos;); } if(Math.abs(slideX)&gt;50 &amp;&amp; &apos;meeting_type&apos; == $(this).children(&apos;li:last-child&apos;).attr(&apos;class&apos;) &amp;&amp; &apos;show-from-right&apos; == $(this).attr(&apos;class&apos;)) { $(this).children(&apos;li:last-child&apos;).hide(); }else if(Math.abs(slideX)&gt;50 &amp;&amp; &apos;meeting_type&apos; == $(this).children(&apos;li:last-child&apos;).attr(&apos;class&apos;) &amp;&amp; &apos;hide-to-right&apos; == $(this).attr(&apos;class&apos;) &amp;&amp; $(this).children(&apos;li:last-child&apos;).text()){ $(this).children(&apos;li:last-child&apos;).show(); }; }) } 3. 监测设备型号(Android/ios)//监测设备型号 function checkEquipment() { if (navigator.userAgent.indexOf(&apos;Android&apos;) &gt; -1 || navigator.userAgent.indexOf(&apos;Adr&apos;) &gt; -1) { return &apos;Android&apos;; } else if (!!navigator.userAgent.match(/\\(i[^;]+;( U;)? CPU.+Mac OS X/)) { return &apos;ios&apos;; } }","tags":[{"name":"js","slug":"js","permalink":"https://github.com/Y-Cwei/Y-Cwei.github.io/tree/master/tags/js/"}]},{"title":"Mint UI 踩坑之路","date":"2018-02-19T11:13:13.000Z","path":"2018/02/19/2018-02-19-Mint UI踩坑之路/","text":"Mint UI 踩坑之路1. Mint UI 之 Cell Swipe 用法 官方API如: Mint UI 之 Cell Swipe Import import { CellSwipe } from &apos;mint-ui&apos; Vue.component(CellSwipe.name, CellSwipe) Example &lt;mt-cell-swipe title=&quot;text&quot; :right=&quot;[ { content: &apos;Delete&apos;, style: { background: &apos;red&apos;, color: &apos;#fff&apos; }, handler: () =&gt; this.$messagebox(&apos;delete&apos;) } ]&quot;&gt;&lt;/mt-cell-swipe&gt; 注意：标签内 handler 中命名的方法，并不能满足我们的需求，可对其进行如下调整，在methods中自定义一个我们所需处理逻辑的方法 &lt;mt-cell-swipe title=&quot;text&quot; v-for=&quot;(item, index) in lists&quot; :key=&quot;index&quot; :right=&quot;[ { content: &apos;Delete&apos;, style: { background: &apos;red&apos;, color: &apos;#fff&apos; }, handler(){deleteItem(index)} // 1.如此修改此handler方法，会调用我们methods中自定义的方法，注：函数名不能命名为delete,严格模式下回报错 } ]&quot;&gt;&lt;/mt-cell-swipe&gt; methods: { deleteItem (index) { // 2.封装自己处理删除单条数据的方法,index为对应item的索引值 console.log(`删除的为数组中的第${index}项`) } } 注意：handler(){ } 中的方法调用，不需要加 this 2. Mint UI 之 Message box 用法 官方API如：Mint UI 之 Message box Import import { MessageBox } from &apos;mint-ui&apos; Vue.prototype.$messagebox = MessageBox Example this.$messagebox.confirm(&apos;&apos;, { message: `是否确认删除${this.applyLists[index].name}模板？`, title: &apos;&apos;, confirmButtonText: &apos;确认&apos;, cancelButtonText: &apos;取消&apos;, className: &apos;myMessage&apos; }).then(action =&gt; { if (action === &apos;confirm&apos;) { // 确认逻辑 } }).catch(err =&gt; { if (err === &apos;cancel&apos;) { // 取消关闭 } })","tags":[{"name":"Mint UI","slug":"Mint-UI","permalink":"https://github.com/Y-Cwei/Y-Cwei.github.io/tree/master/tags/Mint-UI/"}]},{"title":"charles连接手机抓包","date":"2018-02-19T11:13:13.000Z","path":"2018/02/19/2018-02-19-charles连接手机抓包/","text":"charles连接手机抓包 必须保证电脑和手机在一个局域网下 连接步骤： 打开charles，依次点击 Proxy - Proxy Settings… - 勾选Enable transparent HTTP proxying - ok。 电脑终端 cmd ，输入 ipconfig 查看本机 ip 。 打开手机，连入和电脑相同的局域网关，手动配置http代理，服务器与电脑 ip 保持一致，端口与步骤一Proxy Settings…中的端口号保持一致。 此时charles会给出提示。有新的连接。点击allow。 连接成功，此时手机发送的内容，charles可以抓到。 注意： 然后如果勾选了Proxy - Windows Proxy 的话，那么就会将电脑上的抓包请求也抓取到，如果只抓手机的话，建议取消这个勾选设置。 一百种charles连接不上手机的处理方式： 检查电脑和手机有没有连接的同一个wifi，必须tm连接的一个网 更换charles和移动端设备的端口，默认是8888，可以改成其他的试试 有可能路由器设置的ap间不能相互访问，需要登录路由器，需要登录路由器。进行求改。把用户间访问的对勾勾上。类似于这样 关闭电脑的防火墙。试试 首先，如果，防火墙关了还是不行，那么请把手机wifi断掉后重新连接，这样一般就可以解决问题了。 如果以上方法还是不行的话，那么请将手机wifi位置的ip地址设置成静态ip，然后重启charles工具。 在charles上添加手机的ip试试","tags":[{"name":"charles","slug":"charles","permalink":"https://github.com/Y-Cwei/Y-Cwei.github.io/tree/master/tags/charles/"}]},{"title":"vue过渡类名实现动画","date":"2018-02-12T11:13:13.000Z","path":"2018/02/12/2018-02-12-vue学习笔记之过渡类名实现动画/","text":"vue过渡类名实现动画进入/离开 &amp; 列表过渡","tags":[{"name":"vue","slug":"vue","permalink":"https://github.com/Y-Cwei/Y-Cwei.github.io/tree/master/tags/vue/"}]},{"title":"vue发送get post jsonp请求","date":"2018-02-12T11:13:13.000Z","path":"2018/02/12/2018-02-12-vue学习笔记之如何发送get post jsonp请求/","text":"1. 使用 vue-resource 发送get、 post、 jsonp请求 官方已不再维护 github提供的vue-ersource请求测试地址 使用 vue-resource 发送 get 请求 this.$http.get(&apos;/someUrl&apos;).then(response =&gt; { // get body data console.log(response.body) }, error =&gt; { // error callback }) 使用 vue-resource 发送 post 请求 this.$http.post(&apos;/someUrl&apos;, {body}, {config}).then(response =&gt; { // 默认发起的 post 请求，默认没有表单格式，所以有的服务器处理不了 // 通过查阅文档发现，通过 post 方法的第三个参数，{ emulateJSON：true }设置提交的内容为普通表单数据格式 console.log(response.body) }, error =&gt; { // error callback }) 使用 vue-resource 发送 jsonp 请求 this.$http.jsonp(&apos;/someUrl&apos;, {config}).then(response =&gt; { console.log(response.body) }, error =&gt; { // error callback }) 2.axios请求超时的处理,超时重新发送// 重发次数 axios.defaults.retry = 10 // 间隔时间 axios.defaults.retryDelay = 1000 axios.interceptors.response.use(undefined, function axiosRetryInterceptor (err) { var config = err.config if (!config || !config.retry) return Promise.reject(err) config.__retryCount = config.__retryCount || 0 if (config.__retryCount &gt;= config.retry) { return Promise.reject(err) } config.__retryCount += 1 var backoff = new Promise(function (resolve) { setTimeout(function () { resolve() }, config.retryDelay || 1) }) return backoff.then(function () { return axios(config) }) }) 3.axios设置请求超时,弹窗提示axios.defaults.timeout = 10 * 1000 axios.interceptors.response.use(undefined, error =&gt; { var originalRequest = error.config if (error.code === &apos;ECONNABORTED&apos; &amp;&amp; error.message.indexOf(&apos;timeout&apos;) !== -1 &amp;&amp; !originalRequest._retry) { MessageBox.alert(&apos;网络请求超时,请稍后进行尝试&apos;, &apos;移动OA提示&apos;) } })","tags":[{"name":"vue","slug":"vue","permalink":"https://github.com/Y-Cwei/Y-Cwei.github.io/tree/master/tags/vue/"}]},{"title":"自定义按键修饰符","date":"2018-02-12T11:13:13.000Z","path":"2018/02/12/2018-02-12-vue学习笔记之自定义按键修饰符/","text":"自定义按键修饰符语法： Vue.config.keyCodes.xxx = xxx对应的keyCode值 我们知道，vue为我们提供了部分“见名知意”的按键修饰符，使用方法如下： &lt;input type=&quot;button&quot; value=&quot;保存&quot; @keyup.enter=&quot;save&quot;/&gt; // 点击enter触发 save() 方法 &lt;input type=&quot;button&quot; value=&quot;保存&quot; @keyup.13=&quot;save&quot;/&gt; // 点击enter触发 save() 方法 除此之外，我们想要使用vue尚未提供的按键修饰符，只能使用按键对应的keyCode值，不能很好的见名知意，例如，我们想按f2键来执行一个save()方法，只能查询f2对应的keyCode值，使用如下语法来触发save()方法: &lt;input type=&quot;button&quot; value=&quot;保存&quot; @keyup.113=&quot;save&quot; /&gt; // f2对应的keycode值为113,不能直接使用f2,因为vue事先并未提供 为了更好的见名知意，我们可以通过全局 config.keyCodes 对象自定义按键修饰符别名，例如自定义f2的按键修饰符 Vue.config.keyCodes.f2 = 113 // 当全局自定义完按键修饰符别名f2后，可直接使用f2来达到按键作用 &lt;input type=&quot;button&quot; value=&quot;保存&quot; @keyup.f2=&quot;save&quot; /&gt;","tags":[{"name":"vue","slug":"vue","permalink":"https://github.com/Y-Cwei/Y-Cwei.github.io/tree/master/tags/vue/"}]},{"title":"vue生命周期","date":"2018-02-12T11:13:13.000Z","path":"2018/02/12/2018-02-12-vue学习笔记之生命周期钩子函数/","text":"vue生命周期生命周期图示: vue实例创建阶段的四个函数 beforeCreated () { // 此函数表示实例完全被创建出来之前，会执行它 // 注意： 在此生命周期函数执行的时候，data和methods中的数据还没有被初始化，故不能调用对data中的数据进行修改及调用methods中的方法 } created () { // 在此生命周期函数执行时，data和methods都已经初始化好了 // 如果要调用 methods 中的方法，或者操作 data 中的数据，最早也只能在此函数中进行操作 } beforeMount () { // 此函数表明，模板已经在内存中编辑完成了，但是尚未挂载到页面中 // 在此函数执行的时候，页面中的元素，还没有被真正的渲染 } mounted () { // 此函数表示，内存中的数据，已经真实的挂载到了页面中，用户已经可以看到真实的渲染好的页面了 // mounted是实例创建期间的最后一个生命周期函数，当执行完 mounted 就表示，实例已经被完全创建好了，此时，如果没有其它操作的话，这个实例，就静静的躺在内存中，一动不动 // 此时，组件已经脱离了创建阶段，进入到运行阶段 } vue实例运行时的函数 beforeUpdate () { // 当 data 中的数据发生变化时，会执行此函数，当执行此函数时，页面中显示的数据，依然是 data 更新之前的旧数据，但 data 在内存中的数据已经是最新的了，页面尚未和最新的数据保持同步 } updated () { // 此时页面和 data 数据已经保持同步了 } vue实例销毁时的函数 beforeDestory () { // 当执行此函数时，就表示Vue实例已经从运行阶段，进入到销毁阶段， // 当执行此函数时，实例上data中所有的数据和methods中的方法，一级指令，过滤器...都处于可用状态，还没有这正执行销毁过程 // 此方法中，一般做一些诸如定时器等的销毁收尾工作 } destoryed () { // 当执行此函数时，组件已经被完全销毁了，此时，组件中所有的数据，方法，指令，过滤器...都已经不可用了 }","tags":[{"name":"vue","slug":"vue","permalink":"https://github.com/Y-Cwei/Y-Cwei.github.io/tree/master/tags/vue/"}]},{"title":"自定义全局/私有指令","date":"2018-02-12T11:13:13.000Z","path":"2018/02/12/2018-02-12-vue学习笔记之自定义全局和私有指令/","text":"自定义全局/私有指令语法： 全局指令： Vue.directive(‘xxx’, {}) 私有指令： directives: {‘xxx’, {}} 在 main.js 中使用 Vue.directive(&#39;xxx&#39;, {}) 定义全局指令，此方法接受两个参数 参数1： 指令的名称； 注意：在定义的时候，指令的名称前面，不需要加 v- 前缀，但在调用的时候，必须在指令名称前加上 v- 前缀来进行使用 参数2： 一个对象，这个对象上，有一些指令相关的函数，这些函数可以在特定的阶段，执行相关的操作，对应的函数如下（自定义获取焦点的指令）： Vue.directive(&apos;focus&apos;, { bind: el =&gt; { // 每当指令绑定到元素上时，会立即触发这个bind函数，只执行一次 // 在元素刚绑定了指令的时候，还没有插入到DOM中去，这时候，调用操作DOM的方法，并不生效，故在此调用 el.focus()，并不生效 // 因为一个元素只有在插入DOM之后，才能获取焦点 el.focus() // 不生效 }, inserted: el =&gt; { // 该方法表示元素插入到DOM中的时候，会执行inserted函数，同样只执行一次 el.focus() // 此处调用操作DOM的方法生效，因为元素已经插入到DOM树中 }, updated: el =&gt; { // 当VNode更新时，会触发updated方法，该方法会触发多次 } }) 注意： 在每个函数中，第一个参数，永远是 el ,表示被绑定了指令的那个元素，这个 el 参数，是一个原生的js对象，可调用原生的js方法 和样式相关的操作，在bind中写，和行为相关的，在inserted中写，因为诸如el.style.color = “red”设置的内联样式来说，最终都要插入到页面中去 当自定义好全局指令后，可直接在标签内使用 v-xxx 绑定指令 &lt;input type=&quot;text&quot; v-foucs /&gt; 如果想注册局部指令，组件中接受一个 directives （带s）的选项 directives: { focus: { bind: el =&gt; { }, inserted: el =&gt; { }, updated: el =&gt; { } } } // 然后可以在模板中任何元素上使用新的 v-focus 属性，如下： &lt;input type=&quot;text&quot; v-focus /&gt; 点此查看钩子函数对应的其它参数 // 如有需求：动态的修改输入框字体的颜色，可自定义 color 指令 Vue.directive(&apos;color&apos;, { bind: (el, binding) =&gt; { el.style.color = binding.value } }) // 指定按如下方式绑定，注意参数需带引号，否则为变量，会去data中查值 &lt;input type=&quot;text&quot; v-color=&quot;&apos;red&apos;&quot; /&gt; // 输入框为红色字体 &lt;input type=&quot;text&quot; v-color=&quot;&apos;blue&apos;&quot; /&gt; // 输入框为蓝色字体 注意：指令的绑定，遵从就近原则，意：当某一指令，在全局和局部都有自定义时，优先绑定局部指令 自定义指令函数的简写 语法: 在很多时候，你可能想在 bind 和 update 时触发相同行为，而不关心其它的钩子。比如这样写: Vue.directive(‘xxx’, function (el, binding) {}) // 自定义修改字体大小的指令 // 全局指令 Vue.directive(&apos;fontsize&apos;, (el, binding) =&gt; { el.style.fontSize = parseInt(binding.value) + &apos;px&apos; }) // 私有指令 directives: { fontsize: (el, binding) =&gt; { el.style.fontSize = parseInt(binding.value) + &apos;px&apos; } } // 使用 &lt;input type=&quot;text&quot; v-fontsize=&quot;50&quot; /&gt; &lt;input type=&quot;text&quot; v-fontsize=&quot;&apos;50px&apos;&quot; /&gt;","tags":[{"name":"vue","slug":"vue","permalink":"https://github.com/Y-Cwei/Y-Cwei.github.io/tree/master/tags/vue/"}]},{"title":"dropload.js使用介绍","date":"2018-01-11T11:13:13.000Z","path":"2018/01/11/2018-01-11-一款精简的移动端上拉加载下拉刷新插件/","text":"dropload.js一款精简的移动端上拉加载下拉刷新插件最近在做一个移动端上拉加载下拉刷新功能，无意中发现了此插件，使用简单方便，奈何坑太多！点击查看dropload.js相关介绍及demo下载 ####使用介绍： 将下载好的dropload.js插件中的dropload.js，dropload.css引入页面当中，注意引入dropload.js之前，要保证已经引入Jquery 1.7及Zepto文件。","tags":[{"name":"js","slug":"js","permalink":"https://github.com/Y-Cwei/Y-Cwei.github.io/tree/master/tags/js/"}]},{"title":"javascript基础","date":"2017-08-05T11:13:13.000Z","path":"2017/08/05/2017-08-05-javascript基础之数组的操作/","text":"javascript基础一. js对数组的操作1. 数组的基本操作之 —— 增/删 (push(), pop(), unshift(), shift()) 操作 增： push(): 向数组后添加内容，可接受任意数量的参数，会对原数组产生影响,返回修改后数组的长度 删： pop(): 删除数组最后一个元素，不接收参数，会对原数组产生影响，返回被删除的元素值，如果数组为空，则返回 undefined 增：unshift(): 向数组开头添加内容，可接受任意参数量的参数，会对原数组产生影响，返回修改后的数组的长度 删： shift(): 删除数组第一个元素，不接收参数，会对原数组产生影响，返回被删除的元素值，如果数组为空，则返回 undefined var pushNumber = [1, 2, 3, 4, 5, 6]; var pushResult1 = pushNumber.push(7, &apos;帅气&apos;); console.log(pushResult1); // 8 console.log(pushNumber); // [1, 2, 3, 4, 5, 6, 7, &apos;帅气&apos;] var pushResult2 = pushNumber.unshift([7, &apos;帅气&apos;]); // 注意添加的是一个数组，为一项 console.log(pushResult2); // 9 console.log(pushNumber); // [[7, &apos;帅气&apos;], 1, 2, 3, 4, 5, 6, 7, &apos;帅气&apos;]; var popNumber = [1, 2, 3, 4, 5, 6]; var popResult1 = popNumber.pop(); console.log(popResult1); // 6 console.log(popNumber); // [1, 2, 3, 4, 5] var popResult2 = popNumber.shift(); console.log(popResult2); // 1 console.log(popNumber); // [2, 3, 4, 5] 2. 数组的基本操作之 —— 通过指定索引对指定位置添加或者删除相应位置的元素(splice(), slice()) 说明：splice(): 从数组中添加或删除元素，返回被删除的项目，如果是添加，则返回一个空数组（注：会对原数组进行更改，获取的是新的数组），使用如下：a. 使用splice()方法添加元素：splice(index, 0, data1, data2, …)，添加时，splice()方法返回一个空数组;参数解析： index(插入的元素的起始位置，值为1，就是第一位开始，并非索引值), 0(删除的个数), data1/data2/…(添加的元素)； // 向数组第一项之后插入新值 var spliceAddArr = [1, 2, 3, 4, 5, 6]; var spliceAddResult = spliceAddArr.splice(1, 0, &apos;a&apos;, &apos;b&apos;, &apos;c&apos;); console.log(&apos;spliceAddArr: &apos;, spliceAddArr, &apos;; spliceAddResult: &apos;, spliceAddResult); // spliceAddArr: [1, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, 2, 3, 4, 5, 6] ; spliceAddResult: [] b.1 使用splice()方法删除元素： splice(index, 3)，删除时，splice()方法返回被删除的元素的数组集合（注：会对原数组进行更改，原数组变更为删除之后的新数组）参数解析： index(删除元素的起始位置，值为1，就是从第一位开始，并非索引值)，3(删除的个数)b.2 使用splice()方法删除元素的同时添加元素： splice(index, 3, data1, data2, …)参数解析： index(删除元素的起始位置，值为1，就是从第一位开始，并非索引值)，3(删除的个数)，data1/data2/…（添加的元素）； // 使用splice()删除元素，返回被删除元素 var spliceDelArr = [1, 2, 3, 4, 5, 6]; var spliceDelResult = spliceDelArr.splice(1, 3); console.log(&apos;spliceDelArr: &apos;, spliceDelArr, &apos;; spliceDelResult: &apos;, spliceDelResult); // spliceDelArr: [1, 5, 6] ; spliceDelResult: [2, 3, 4] // 使用splice()删除元素的同时添加元素 var spliceAddArr = [1, 2, 3, 4, 5, 6]; var spliceAddResult = spliceAddArr.splice(1, 3, &apos;a&apos;, &apos;b&apos;, &apos;c&apos;); console.log(&apos;spliceAddArr: &apos;, spliceAddArr, &apos;; spliceAddResult: &apos;, spliceAddResult); // spliceDelArr: [1, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, 5, 6] ; spliceDelResult: [2, 3, 4] 注： 使用splice(),不管是用来添加还是删除元素，第一个参数都可以接受一个负数作为参数，与正数相比：相同之处：使用splice()添加元素，都是从起始位置的之后添加，即如果是正3，即从起始位置往后数3位添加，即从第三第四位中间添加元素，若为负数-3，即从后往前数三位的后一位，即从后往前数第三位到第四位中间添加，如果第一个参数，大于数组的实际长度，则从数组的末尾开始添加。不同之处：使用splice()删除元素，如果是正数3，如： splice(3, 3),即从开始位置往后数三位，从第四位开始删除三项，实际删除的是第四，第五，第六项，而当为负数-3时，如： splice(-3, 3)，即从后往前数三位，从倒数第三位开始删除，并不是倒数第四位，实际删除的项为倒数第三项，倒数第二项，倒数第一项三项。如果删除的项数大于起始位置到数组的结束位置的项数，则默认到数组结束位置停止。 // splice()添加，index为正数时 var arr1 = [1, 2, 3, 4, 5]; var arrRes1 = arr1.splice(3, 0, &apos;a&apos;, &apos;b&apos;, &apos;c&apos;); console.log(&apos;arr1: &apos;, arr1, &apos;; arrRes1:&apos;, arrRes1); // arr1: [1, 2, 3, &apos;a&apos;, &apos;b&apos;, &apos;c&apos;, 4, 5] ； arrRes1： [] // splice()添加，index为负数时 var arr2 = [1, 2, 3, 4, 5]; var arrRes2 = arr2.splice(-3, 0, &apos;a&apos;, &apos;b&apos;, &apos;c&apos;); console.log(&apos;arr2: &apos;, arr2, &apos;; arrRes2:&apos;, arrRes2); // arr2: [1, 2, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, 3, 4, 5] ; arrRes2: [] // splice()删除，index为正数时 var arr3 = [1, 2, 3, 4, 5, 6, 7]; var arrRes3 = arr3.splice(3, 3, &apos;a&apos;, &apos;b&apos;, &apos;c&apos;); console.log(&apos;arr3: &apos;, arr3, &apos;; arrRes3:&apos;, arrRes3); // arr3: [1, 2, 3, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, 7] ； arrRes3： [4, 5, 6] // splice()删除，index为正数时 var arr4 = [1, 2, 3, 4, 5, 6, 7]; var arrRes4 = arr4.splice(-3, 3, &apos;a&apos;, &apos;b&apos;, &apos;c&apos;); console.log(&apos;arr4: &apos;, arr4, &apos;; arrRes4:&apos;, arrRes4); // arr3: [1, 2, 3, 4, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;] ； arrRes3： [5, 6, 7] slice()使用说明：用于截取数组，返回截取到的新的数组，此方法可以作用于字符串属性（注：不会影响原数组）;此方法接受两个参数，slice(start, end)：start: 必传，截取开始位置的下标,end: 可传，截取结束的位置下标索引，不包括当前下标对应的元素，不传为数组结束。 var sliceArr = [1, 2, 3, 4, 5, 6, 7]; var sliceRes0 = sliceArr.slice(2); // 实际截取的为：第三项到数组结束 var sliceRes1 = sliceArr.slice(2, 4); // 实际截取的为：第三项，第四项 var sliceRes2 = sliceArr.slice(-2); // 实际截取的为：第三项，第四项 var sliceRes3 = sliceArr.slice(-9); // 从后往前第九位，数组长度不够，从第一项开始截取到数组结束 var sliceRes4 = sliceArr.slice(-4, -2); // 实际截取的为从倒数第四项到倒数第二项：即为倒数第四项，倒数第五项两项 var sliceRes5 = sliceArr.slice(-4, -6); // 无匹配项，返回一个空数组 var sliceRes6 = sliceArr.slice(1, -2); // 从索引为1的位置开始，到倒数第二项，不包括倒数第二项 var sliceRes7 = sliceArr.slice(9); // 无匹配项，返回一个空数组 console.log(&apos;sliceArr: &apos;, sliceArr, &apos;； sliceRes0: &apos;, sliceRes0); // sliceArr1: [1, 2, 3, 4, 5, 6, 7] ; sliceRes0: [3, 4, 5, 6, 7] console.log(&apos;sliceRes1: &apos;, sliceRes1); // sliceRes1: [3, 4] console.log(&apos;sliceRes2: &apos;, sliceRes2); // sliceRes2: [6, 7] console.log(&apos;sliceRes3: &apos;, sliceRes3); // sliceRes3: [1, 2, 3, 4, 5, 6, 7] console.log(&apos;sliceRes4: &apos;, sliceRes4); // sliceRes4: [4, 5] console.log(&apos;sliceRes5: &apos;, sliceRes5); // sliceRes5: [] console.log(&apos;sliceRes6: &apos;, sliceRes6); // sliceRes6: [2, 3, 4, 5] console.log(&apos;sliceRes7: &apos;, sliceRes7); // sliceRes7: [] 3. 数组的基本操作之 —— 对数组的每一项进行操作(map(), forEach()) 相同点: 都是循环遍历数组中每一项 map和forEach每次执行匿名函数时都支持3个参数，参数分别是item(当前项)，index(索引值)，arr(原数组) 匿名函数中的this都指向 window 只能遍历数组 都不会改变原数组 区别：map方法： map方法返回一个新的数组，数组中的元素为原始数组调用函数处理之后的值 map方法不会对空数组进行检测(即不会执行匿名函数，若为空数组，则调用map方法后也返回一个空数组)，map方法不会改变原始数组 浏览器支持： chrome / Safari 1.5+ / opera / IE9+forEach方法： forEach()方法用来调用数组的每个元素，将元素传给回调函数 forEach()方法不会对空数组进行检测，对于空数组是不会调用匿名函数的，注意，无论数组是否为空，调用forEach方法，返回值均为 undefined // map方法 var mapArr = [1, 2, 3, 4, 5]; var mapResult = mapArr.map(function(item, index, arr){ console.log(this); // window console.log(&apos;原始数组mapArr: &apos;, arr); // 原始数组mapArr: [1, 2, 3, 4, 5] return item+1; }) console.log(&apos;mapArr:&apos;, mapArr, &apos;; mapResult: &apos;, mapResult); // mapArr: [1, 2, 3, 4, 5] ; mapResult: [2, 3, 4, 5, 6] // 若为空数组，调用map方法，返回一个空数组，匿名函数不会执行 var empArr = []; var mapEmpResult = empArr.map(function(){item, index, arr}{ // 空数组调用map方法，函数体不会执行 console.log(this); console.log(&apos;原始数组mapArr: &apos;, arr); return item+1; })； console.log(&apos;empArr:&apos;, empArr, &apos;; mapEmpResult: &apos;, mapEmpResult); // empArr: [] ; mapEmpResult: [] // forEach方法 var forEachArr = [1, 2, 3, 4, 5]; var forEachResult = forEachArr.forEach(function(item, index, arr){ // 调用forEach()方法，返回值均为 undefined console.log(this); // window console.log(&apos;原始数组forEachArr：&apos;, arr); // 原始数组forEachArr： [1, 2, 3, 4, 5] return item+1; }) console.log(&apos;forEachArr:&apos;, forEachArr, &apos;; forEachResult: &apos;, forEachResult); // forEachArr: [1, 2, 3, 4, 5] ; forEachResult: undefined 4. 数组的基本操作之 —— 对数组的每一项进行操作（ filter() ） 说明： 遍历每一项数组，接收一个匿名函数作为参数，函数接收三个参数，参数item(遍历得到的每一项数组值)，index（索引值），arr(数组本身)， 返回一个结果为true的item组成的新数组，不会影响原数组 // 需求：获取成绩合格的学生名单 var students = [ {name: &apos;张三&apos;, age: 18, scroe: 89}, {name: &apos;李四&apos;, age: 17, scroe: 71}, {name: &apos;王五&apos;, age: 18, scroe: 56}, {name: &apos;赵六&apos;, age: 19, scroe: 94}, {name: &apos;小明&apos;, age: 18, scroe: 48}, {name: &apos;小红&apos;, age: 19, scroe: 60}, ]; var studentsResult = students.filter(function(item){ if (item.scroe &gt;= 60) { return { name: item.name, age: item.age, score: item.scroe } } }); console.log(studentsResult); // 输出如下结果 // [{name: &quot;张三&quot;, age: 18, scroe: 89}, // {name: &quot;李四&quot;, age: 17, scroe: 71}, // {name: &quot;赵六&quot;, age: 19, scroe: 94}, // {name: &quot;小红&quot;, age: 19, scroe: 60}] 5. 数组的基本操作之 —— 对数组的迭代方法(every(), some())方法 说明：every()和some()都是对js中数组的迭代方法，区别如下：相同点： 均接收一个匿名函数作为参数，函数接收三个参数，参数item(每一项),index（索引值），arr(原始数组) 均对数组的每一项运行指定的匿名函数 不同点:every(): 对数组的每一项运行给定的函数，如果该函数每一项都返回 true, 则返回 true，若存在某项返回false，则终止函数迭代，返回false; (可用来判断是不是所有，类似于逻辑 &amp;&amp;)some(): 对数组的每一项运行给定的函数，如果该函数存在某一项返回 true, 函数终止，并返回 true; (可用来判断有没有，类似于逻辑 ||) // 判断数组是是否全为基数 // 使用every()方法实现 var everyArr1 = [1, 3, 5, 7, 9]; var everyArr2 = [1, 3, 5, 6, 7, 9]; var everyResult1 = everyArr1.every(function(item, index, arr){ if (!(item % 2)) { console.log(&apos;第&apos;+(index+1)+&apos;项为偶数,值为：&apos;+item); } return item % 2; }); var everyResult2 = everyArr2.every(function(item, index, arr){ if (!(item % 2)) { console.log(&apos;第&apos;+(index+1)+&apos;项为偶数,值为：&apos;+item); // 第4项为偶数,值为：6 } return item % 2; }); console.log(everyResult1?&apos;everyArr1的每一项均为基数&apos;:&apos;everyArr1的存在某一项不为基数&apos;); // everyArr的每一项均为基数 console.log(everyResult2?&apos;everyArr2的每一项均为基数&apos;:&apos;everyArr2的存在某一项不为基数&apos;); // everyArr2的存在某一项不为基数 // 使用some()方法实现 var someArr1 = [1, 3, 5, 7, 9]; var someArr2 = [1, 3, 5, 6, 7, 9]; var someResult1 = someArr1.some(function (item, index, arr) { if (!(item % 2)) { console.log(&apos;第&apos; + (index + 1) + &apos;项为偶数,值为：&apos; + item); }; return !(item % 2); }); var someResult2 = someArr2.some(function (item, index, arr) { if (!(item % 2)) { console.log(&apos;第&apos; + (index + 1) + &apos;项为偶数,值为：&apos; + item); // 第4项为偶数,值为：6 }; return !(item % 2); }); console.log(!someResult1 ? &apos;someArr1的每一项均为基数&apos; : &apos;someArr1的存在某一项不为基数&apos;); // someArr1的每一项均为基数 console.log(!someResult2 ? &apos;someArr2的每一项均为基数&apos; : &apos;someArr2的存在某一项不为基数&apos;); // someArr2的存在某一项不为基数","tags":[{"name":"js","slug":"js","permalink":"https://github.com/Y-Cwei/Y-Cwei.github.io/tree/master/tags/js/"}]},{"title":"js对字符串的操作","date":"2017-08-05T11:13:13.000Z","path":"2017/08/05/2017-08-05-javascript基础之字符串操作/","text":"js对字符串的操作1. 将其它类型的数据转换为字符串 语法：可以调用 stringObj.toString() 方法，String(stringObj) 方法，或者饮食转化 “” + stringObj;使用如下： var num = 19; var numStr0 = num.toString(); var numStr1 = String(num); var numStr2 = &apos;&apos; + num; 2. 获取字符串的长度 语法：stringObj.length var str = &apos;javaScript&apos;; console.log(str.length); // 10 3. 字符串替换 语法：stringObj.replace(rgExp, replaceText)，返回替换后的字符串，原字符串不变，参数说明如下：reExp可以是正则表达式对象(RegExp)，也可以是字符串(string)，replaceText是替代的查找到的字符串；使用如下： var str = &apos;php是世界上最好的语言&apos;; var strRes = str.replace(&apos;php&apos;, &apos;javascript才&apos;); console.log(str + &apos;?开玩笑，&apos; + strRes); 4. 查找给定位置的字符或其字符编码值 语法： 查找指定位置的字符： stringObj.charAt(index)，返回查找到的字符，不影响原数组；参数解析，index为要查找的指定位置字符的下标索引。 查找指定位置字符的字符编码值，stringObj.charCodeAt(index) // 获取指定位置的字符 var str = &apos;javaScript&apos;; var strCharAt = str.charAt(6); var strCharCodeAt = str.charCodeAt(6); console.log(str+&quot;的第7位字符是:&quot;+strCharAt+&quot;,其字符编码值为：&quot;+strCharCodeAt); // javaScript的第7位字符是:r,其字符编码值为：114 5. 字符串连接 语法： 直接使用 + ， stringObj.concat(stringObj2)，返回拼接后的字符串，对原字符串无影响 var firstStr = &apos;java&apos;; var lastStr = &apos;script&apos;; var strRes = firstStr.concat(lastStr); console.log(strRes+&quot;是由字符串&quot;+firstStr+&apos;和&apos;+lastStr+&apos;拼接而成的&apos;); // javascript是由字符串java和script拼接而成的 6. 字符串的切割和提取 语法： stringObj.slice(start, end)，返回截取得到的字符串，不影响原字符串， stringObj.substring(start, end)，返回截取得到的字符串，不影响原字符串， stringObj.substr(start, end)，返回截取得到的字符串，不影响原字符串。参数解析： 对于slice()和substring()方法而言：start： 必选，非负，指定开始位置的下标，end: 可选，非负，指定结束位置的下标，不传，默认到字符串末尾，返回的子串包括 start 处的字符，但不包括 stop 处的字符。 对于substr()方法而言：start: 必选，非负，指定开始位置的下标，end: 可选，非负，指定截取的最大长度，不传，默认到字符串结尾。 对于三种方法而言，参数end如果是一个大于字符串长度的值，则截取到字符串结尾终止 var str = &apos;javaScript&apos;; var sliceStr0 = str.slice(1, 5); var sliceStr1 = str.slice(1, 15); var substringStr0 = str.substring(1, 5); var substringStr1 = str.substring(1, 15); var substrStr0 = str.substr(1, 5); var substrStr1 = str.substr(1, 15); console.log(str); // javascript console.log(sliceStr0); // avaS console.log(sliceStr1); // avaScript console.log(substringStr0); // avaS console.log(substringStr1); // avaScript console.log(substrStr0); // avaSc console.log(substrStr1); // avaScript 8. 字符串大小写转换 语法：stringObj.toLowerCase(): 将字符串转换为小写，返回被转换之后的字符串，不影响原字符串。stringObj.toLocaleLowerCase(): 将字符串转换为小写，返回被转换之后的字符串，不影响原字符串。stringObj.toUpperCase(): 将字符串转换为大写，返回被转换之后的字符串，不影响原字符串。stringObj.toLocaleUpperCase(): 将字符串转换为大写，返回被转换之后的字符串，不影响原字符串。 var str = &apos;JavaScript&apos;; var lowerCase = str.toLowerCase(); var localLowerCase = str.toLocaleLowerCase(); console.log(str+&quot;转化为小写为：&quot;+lowerCase); // JavaScript转化为小写为：javascript console.log(str+&quot;转化为小写为：&quot;+localLowerCase); // JavaScript转化为小写为：javascript var upperCase = str.toUpperCase(); var localUpperCase = str.toLocaleUpperCase(); console.log(str+&quot;转化为大写为：&quot;+upperCase); // JavaScript转化为大写为：JAVASCRIPT console.log(str+&quot;转化为大写为：&quot;+localUpperCase); // JavaScript转化为大写为：JAVASCRIPT 7. 把字符串分割成数组 —— split() 用法： stringObject.split(separator,howmany)separator：必选，类型为字符串或者数组，指定要切割的地方。(返回数组含用来指定切割的字符)howmany：可选择，返回数组的最大长度。 var str1 = &apos;JavaScript&apos;; console.log(str1.split(&apos;&apos;)); // [&quot;J&quot;, &quot;a&quot;, &quot;v&quot;, &quot;a&quot;, &quot;S&quot;, &quot;c&quot;, &quot;r&quot;, &quot;i&quot;, &quot;p&quot;, &quot;t&quot;] console.log(str1.split(&apos;&apos;, 6)); // [&quot;J&quot;, &quot;a&quot;, &quot;v&quot;, &quot;a&quot;, &quot;S&quot;, &quot;c&quot;] console.log(str1.split(&apos;&apos;, 20)); // [&quot;J&quot;, &quot;a&quot;, &quot;v&quot;, &quot;a&quot;, &quot;S&quot;, &quot;c&quot;, &quot;r&quot;, &quot;i&quot;, &quot;p&quot;, &quot;t&quot;] var str2 = &apos;Java Script&apos;; console.log(str2.split(/\\s+/)); // [&quot;Java&quot;, &quot;Script&quot;] 8. 查询字符串 语法：stringOb.indexOf(searchvalue,fromindex),从字符串的开头开始查找，找到返回对应的下标，找不到返回-1，此方法对大小写敏感。stringOb.lastIndexOf(searchvalue,fromindex),从字符串的末尾开始查找，找到返回对应的下标，找不到返回-1，此方法对大小写敏感。参数解析：相同点：searchvalue：必须，规定检索的字符串值不同点：indexOf()方法中参数fromindex：可选，开始检索的地方，从哪开始查找，合法取值：0—stringObject.length，当然不合法取个负值也是不会报错的只是会被视作0或者说空lastIndexOf()方法中的参数fromindex：可选，建议不填，奇妙的第二个参数，能不用就不用 var str1 = &apos;Java Script&apos;; console.log(str1.indexOf(&apos;a&apos;)); // 1 console.log(str1.lastIndexOf(&apos;a&apos;)); // 3 console.log(str1.indexOf(&apos;a&apos;, 1)); // 1 console.log(str1.lastIndexOf(&apos;a&apos;, 1)); // 1 console.log(str1.indexOf(&apos;a&apos;, 2)); // 3 console.log(str1.lastIndexOf(&apos;a&apos;, 1)); // 1 注：调用此方法，要查询的指定字符若存在于目标字符串中，则返回对应的下标，若不存在，则返回 -1 ，可根据此特性，来判断某一字符串中是否含有某一指定字符，如： // 判断str1中是否含有字符&apos;a&apos; var str1 = &apos;Java Script&apos;; function checkStr (targetStr) { if (str1.indexOf(targetStr) &gt; -1) { alert(&apos;str1中含有字符&apos;+targetStr); } else { alert(&apos;str1中不含有字符&apos;+targetStr); } } // 检查是否含有字符&apos;a&apos; checkStr(&apos;a&apos;); // 检查是否含有字符&apos;abc&apos; checkStr(&apos;abc&apos;); 9. 面试题function getSuffix(file){ return file.slice(file.lastIndexOf(&quot;.&quot;) + 1,file.length); } console.log(getSuffix(&apos;test.min.js&apos;)); // js","tags":[{"name":"js","slug":"js","permalink":"https://github.com/Y-Cwei/Y-Cwei.github.io/tree/master/tags/js/"}]}]