{"pages":[],"posts":[{"title":"","text":"js对字符串的操作1. 将其它类型的数据转换为字符串 语法：可以调用 stringObj.toString() 方法，String(stringObj) 方法，或者饮食转化 “” + stringObj;使用如下： var num = 19; var numStr0 = num.toString(); var numStr1 = String(num); var numStr2 = &apos;&apos; + num; 2. 获取字符串的长度 语法：stringObj.length var str = &apos;javaScript&apos;; console.log(str.length); // 10 3. 字符串替换 语法：stringObj.replace(rgExp, replaceText)，返回替换后的字符串，原字符串不变，参数说明如下：reExp可以是正则表达式对象(RegExp)，也可以是字符串(string)，replaceText是替代的查找到的字符串；使用如下： var str = &apos;php是世界上最好的语言&apos;; var strRes = str.replace(&apos;php&apos;, &apos;javascript才&apos;); console.log(str + &apos;?开玩笑，&apos; + strRes); 4. 查找给定位置的字符或其字符编码值 语法： 查找指定位置的字符： stringObj.charAt(index)，返回查找到的字符，不影响原数组；参数解析，index为要查找的指定位置字符的下标索引。 查找指定位置字符的字符编码值，stringObj.charCodeAt(index) // 获取指定位置的字符 var str = &apos;javaScript&apos;; var strCharAt = str.charAt(6); var strCharCodeAt = str.charCodeAt(6); console.log(str+&quot;的第7位字符是:&quot;+strCharAt+&quot;,其字符编码值为：&quot;+strCharCodeAt); // javaScript的第7位字符是:r,其字符编码值为：114 5. 字符串连接 语法： 直接使用 + ， stringObj.concat(stringObj2)，返回拼接后的字符串，对原字符串无影响 var firstStr = &apos;java&apos;; var lastStr = &apos;script&apos;; var strRes = firstStr.concat(lastStr); console.log(strRes+&quot;是由字符串&quot;+firstStr+&apos;和&apos;+lastStr+&apos;拼接而成的&apos;); // javascript是由字符串java和script拼接而成的 6. 字符串的切割和提取 语法： stringObj.slice(start, end)，返回截取得到的字符串，不影响原字符串， stringObj.substring(start, end)，返回截取得到的字符串，不影响原字符串， stringObj.substr(start, end)，返回截取得到的字符串，不影响原字符串。参数解析： 对于slice()和substring()方法而言：start： 必选，非负，指定开始位置的下标，end: 可选，非负，指定结束位置的下标，不传，默认到字符串末尾，返回的子串包括 start 处的字符，但不包括 stop 处的字符。 对于substr()方法而言：start: 必选，非负，指定开始位置的下标，end: 可选，非负，指定截取的最大长度，不传，默认到字符串结尾。 对于三种方法而言，参数end如果是一个大于字符串长度的值，则截取到字符串结尾终止 var str = &apos;javaScript&apos;; var sliceStr0 = str.slice(1, 5); var sliceStr1 = str.slice(1, 15); var substringStr0 = str.substring(1, 5); var substringStr1 = str.substring(1, 15); var substrStr0 = str.substr(1, 5); var substrStr1 = str.substr(1, 15); console.log(str); // javascript console.log(sliceStr0); // avaS console.log(sliceStr1); // avaScript console.log(substringStr0); // avaS console.log(substringStr1); // avaScript console.log(substrStr0); // avaSc console.log(substrStr1); // avaScript 8. 字符串大小写转换 语法：stringObj.toLowerCase(): 将字符串转换为小写，返回被转换之后的字符串，不影响原字符串。stringObj.toLocaleLowerCase(): 将字符串转换为小写，返回被转换之后的字符串，不影响原字符串。stringObj.toUpperCase(): 将字符串转换为大写，返回被转换之后的字符串，不影响原字符串。stringObj.toLocaleUpperCase(): 将字符串转换为大写，返回被转换之后的字符串，不影响原字符串。 var str = &apos;JavaScript&apos;; var lowerCase = str.toLowerCase(); var localLowerCase = str.toLocaleLowerCase(); console.log(str+&quot;转化为小写为：&quot;+lowerCase); // JavaScript转化为小写为：javascript console.log(str+&quot;转化为小写为：&quot;+localLowerCase); // JavaScript转化为小写为：javascript var upperCase = str.toUpperCase(); var localUpperCase = str.toLocaleUpperCase(); console.log(str+&quot;转化为大写为：&quot;+upperCase); // JavaScript转化为大写为：JAVASCRIPT console.log(str+&quot;转化为大写为：&quot;+localUpperCase); // JavaScript转化为大写为：JAVASCRIPT 7. 把字符串分割成数组 —— split() 用法： stringObject.split(separator,howmany)separator：必选，类型为字符串或者数组，指定要切割的地方。(返回数组含用来指定切割的字符)howmany：可选择，返回数组的最大长度。 var str1 = &apos;JavaScript&apos;; console.log(str1.split(&apos;&apos;)); // [&quot;J&quot;, &quot;a&quot;, &quot;v&quot;, &quot;a&quot;, &quot;S&quot;, &quot;c&quot;, &quot;r&quot;, &quot;i&quot;, &quot;p&quot;, &quot;t&quot;] console.log(str1.split(&apos;&apos;, 6)); // [&quot;J&quot;, &quot;a&quot;, &quot;v&quot;, &quot;a&quot;, &quot;S&quot;, &quot;c&quot;] console.log(str1.split(&apos;&apos;, 20)); // [&quot;J&quot;, &quot;a&quot;, &quot;v&quot;, &quot;a&quot;, &quot;S&quot;, &quot;c&quot;, &quot;r&quot;, &quot;i&quot;, &quot;p&quot;, &quot;t&quot;] var str2 = &apos;Java Script&apos;; console.log(str2.split(/\\s+/)); // [&quot;Java&quot;, &quot;Script&quot;] 8. 查询字符串 语法：stringOb.indexOf(searchvalue,fromindex),从字符串的开头开始查找，找到返回对应的下标，找不到返回-1，此方法对大小写敏感。stringOb.lastIndexOf(searchvalue,fromindex),从字符串的末尾开始查找，找到返回对应的下标，找不到返回-1，此方法对大小写敏感。参数解析：相同点：searchvalue：必须，规定检索的字符串值不同点：indexOf()方法中参数fromindex：可选，开始检索的地方，从哪开始查找，合法取值：0—stringObject.length，当然不合法取个负值也是不会报错的只是会被视作0或者说空lastIndexOf()方法中的参数fromindex：可选，建议不填，奇妙的第二个参数，能不用就不用 var str1 = &apos;Java Script&apos;; console.log(str1.indexOf(&apos;a&apos;)); // 1 console.log(str1.lastIndexOf(&apos;a&apos;)); // 3 console.log(str1.indexOf(&apos;a&apos;, 1)); // 1 console.log(str1.lastIndexOf(&apos;a&apos;, 1)); // 1 console.log(str1.indexOf(&apos;a&apos;, 2)); // 3 console.log(str1.lastIndexOf(&apos;a&apos;, 1)); // 1 注：调用此方法，要查询的指定字符若存在于目标字符串中，则返回对应的下标，若不存在，则返回 -1 ，可根据此特性，来判断某一字符串中是否含有某一指定字符，如： // 判断str1中是否含有字符&apos;a&apos; var str1 = &apos;Java Script&apos;; function checkStr (targetStr) { if (str1.indexOf(targetStr) &gt; -1) { alert(&apos;str1中含有字符&apos;+targetStr); } else { alert(&apos;str1中不含有字符&apos;+targetStr); } } // 检查是否含有字符&apos;a&apos; checkStr(&apos;a&apos;); // 检查是否含有字符&apos;abc&apos; checkStr(&apos;abc&apos;); 9. 面试题function getSuffix(file){ return file.slice(file.lastIndexOf(&quot;.&quot;) + 1,file.length); } console.log(getSuffix(&apos;test.min.js&apos;)); // js","link":"/2017/08/05/javascript基础之字符串操作/"},{"title":"","text":"dropload.js一款精简的移动端上拉加载下拉刷新插件最近在做一个移动端上拉加载下拉刷新功能，无意中发现了此插件，使用简单方便，奈何坑太多！点击查看dropload.js相关介绍及demo下载 ####使用介绍： 将下载好的dropload.js插件中的dropload.js，dropload.css引入页面当中，注意引入dropload.js之前，要保证已经引入Jquery 1.7及Zepto文件。","link":"/2018/01/11/一款精简的移动端上拉加载下拉刷新插件/"},{"title":"","text":"vue生命周期生命周期图示: vue实例创建阶段的四个函数 beforeCreated () { // 此函数表示实例完全被创建出来之前，会执行它 // 注意： 在此生命周期函数执行的时候，data和methods中的数据还没有被初始化，故不能调用对data中的数据进行修改及调用methods中的方法 } created () { // 在此生命周期函数执行时，data和methods都已经初始化好了 // 如果要调用 methods 中的方法，或者操作 data 中的数据，最早也只能在此函数中进行操作 } beforeMount () { // 此函数表明，模板已经在内存中编辑完成了，但是尚未挂载到页面中 // 在此函数执行的时候，页面中的元素，还没有被真正的渲染 } mounted () { // 此函数表示，内存中的数据，已经真实的挂载到了页面中，用户已经可以看到真实的渲染好的页面了 // mounted是实例创建期间的最后一个生命周期函数，当执行完 mounted 就表示，实例已经被完全创建好了，此时，如果没有其它操作的话，这个实例，就静静的躺在内存中，一动不动 // 此时，组件已经脱离了创建阶段，进入到运行阶段 } vue实例运行时的函数 beforeUpdate () { // 当 data 中的数据发生变化时，会执行此函数，当执行此函数时，页面中显示的数据，依然是 data 更新之前的旧数据，但 data 在内存中的数据已经是最新的了，页面尚未和最新的数据保持同步 } updated () { // 此时页面和 data 数据已经保持同步了 } vue实例销毁时的函数 beforeDestory () { // 当执行此函数时，就表示Vue实例已经从运行阶段，进入到销毁阶段， // 当执行此函数时，实例上data中所有的数据和methods中的方法，一级指令，过滤器...都处于可用状态，还没有这正执行销毁过程 // 此方法中，一般做一些诸如定时器等的销毁收尾工作 } destoryed () { // 当执行此函数时，组件已经被完全销毁了，此时，组件中所有的数据，方法，指令，过滤器...都已经不可用了 }","link":"/2018/02/12/vue学习笔记之生命周期钩子函数/"},{"title":"","text":"1. 使用 vue-resource 发送get、 post、 jsonp请求 官方已不再维护 github提供的vue-ersource请求测试地址 使用 vue-resource 发送 get 请求 this.$http.get(‘/someUrl’).then(response =&gt; { // get body data console.log(response.body) }, error =&gt; { // error callback }) 使用 vue-resource 发送 post 请求 this.$http.post(‘/someUrl’, {body}, {config}).then(response =&gt; { // 默认发起的 post 请求，默认没有表单格式，所以有的服务器处理不了 // 通过查阅文档发现，通过 post 方法的第三个参数，{ emulateJSON：true }设置提交的内容为普通表单数据格式 console.log(response.body) }, error =&gt; { // error callback }) 使用 vue-resource 发送 jsonp 请求 this.$http.jsonp(‘/someUrl’, {config}).then(response =&gt; { console.log(response.body) }, error =&gt; { // error callback })","link":"/2018/02/12/vue学习笔记之如何发送get post jsonp请求/"},{"title":"","text":"自定义全局/私有指令语法： 全局指令： Vue.directive(‘xxx’, {}) 私有指令： directives: {‘xxx’, {}} 在 main.js 中使用 Vue.directive('xxx', {}) 定义全局指令，此方法接受两个参数 参数1： 指令的名称； 注意：在定义的时候，指令的名称前面，不需要加 v- 前缀，但在调用的时候，必须在指令名称前加上 v- 前缀来进行使用 参数2： 一个对象，这个对象上，有一些指令相关的函数，这些函数可以在特定的阶段，执行相关的操作，对应的函数如下（自定义获取焦点的指令）： Vue.directive(&apos;focus&apos;, { bind: el =&gt; { // 每当指令绑定到元素上时，会立即触发这个bind函数，只执行一次 // 在元素刚绑定了指令的时候，还没有插入到DOM中去，这时候，调用操作DOM的方法，并不生效，故在此调用 el.focus()，并不生效 // 因为一个元素只有在插入DOM之后，才能获取焦点 el.focus() // 不生效 }, inserted: el =&gt; { // 该方法表示元素插入到DOM中的时候，会执行inserted函数，同样只执行一次 el.focus() // 此处调用操作DOM的方法生效，因为元素已经插入到DOM树中 }, updated: el =&gt; { // 当VNode更新时，会触发updated方法，该方法会触发多次 } }) 注意： 在每个函数中，第一个参数，永远是 el ,表示被绑定了指令的那个元素，这个 el 参数，是一个原生的js对象，可调用原生的js方法 和样式相关的操作，在bind中写，和行为相关的，在inserted中写，因为诸如el.style.color = “red”设置的内联样式来说，最终都要插入到页面中去 当自定义好全局指令后，可直接在标签内使用 v-xxx 绑定指令 &lt;input type=&quot;text&quot; v-foucs /&gt; 如果想注册局部指令，组件中接受一个 directives （带s）的选项 directives: { focus: { bind: el =&gt; { }, inserted: el =&gt; { }, updated: el =&gt; { } } } // 然后可以在模板中任何元素上使用新的 v-focus 属性，如下： &lt;input type=&quot;text&quot; v-focus /&gt; 点此查看钩子函数对应的其它参数 // 如有需求：动态的修改输入框字体的颜色，可自定义 color 指令 Vue.directive(&apos;color&apos;, { bind: (el, binding) =&gt; { el.style.color = binding.value } }) // 指定按如下方式绑定，注意参数需带引号，否则为变量，会去data中查值 &lt;input type=&quot;text&quot; v-color=&quot;&apos;red&apos;&quot; /&gt; // 输入框为红色字体 &lt;input type=&quot;text&quot; v-color=&quot;&apos;blue&apos;&quot; /&gt; // 输入框为蓝色字体 注意：指令的绑定，遵从就近原则，意：当某一指令，在全局和局部都有自定义时，优先绑定局部指令 自定义指令函数的简写 语法: 在很多时候，你可能想在 bind 和 update 时触发相同行为，而不关心其它的钩子。比如这样写: Vue.directive(‘xxx’, function (el, binding) {}) // 自定义修改字体大小的指令 // 全局指令 Vue.directive(&apos;fontsize&apos;, (el, binding) =&gt; { el.style.fontSize = parseInt(binding.value) + &apos;px&apos; }) // 私有指令 directives: { fontsize: (el, binding) =&gt; { el.style.fontSize = parseInt(binding.value) + &apos;px&apos; } } // 使用 &lt;input type=&quot;text&quot; v-fontsize=&quot;50&quot; /&gt; &lt;input type=&quot;text&quot; v-fontsize=&quot;&apos;50px&apos;&quot; /&gt;","link":"/2018/02/12/vue学习笔记之自定义全局和私有指令/"},{"title":"","text":"自定义按键修饰符语法： Vue.config.keyCodes.xxx = xxx对应的keyCode值 我们知道，vue为我们提供了部分“见名知意”的按键修饰符，使用方法如下： &lt;input type=&quot;button&quot; value=&quot;保存&quot; @keyup.enter=&quot;save&quot;/&gt; // 点击enter触发 save() 方法 &lt;input type=&quot;button&quot; value=&quot;保存&quot; @keyup.13=&quot;save&quot;/&gt; // 点击enter触发 save() 方法 除此之外，我们想要使用vue尚未提供的按键修饰符，只能使用按键对应的keyCode值，不能很好的见名知意，例如，我们想按f2键来执行一个save()方法，只能查询f2对应的keyCode值，使用如下语法来触发save()方法: &lt;input type=&quot;button&quot; value=&quot;保存&quot; @keyup.113=&quot;save&quot; /&gt; // f2对应的keycode值为113,不能直接使用f2,因为vue事先并未提供 为了更好的见名知意，我们可以通过全局 config.keyCodes 对象自定义按键修饰符别名，例如自定义f2的按键修饰符 Vue.config.keyCodes.f2 = 113 // 当全局自定义完按键修饰符别名f2后，可直接使用f2来达到按键作用 &lt;input type=&quot;button&quot; value=&quot;保存&quot; @keyup.f2=&quot;save&quot; /&gt;","link":"/2018/02/12/vue学习笔记之自定义按键修饰符/"},{"title":"","text":"vue过渡类名实现动画进入/离开 &amp; 列表过渡","link":"/2018/02/12/vue学习笔记之过渡类名实现动画/"},{"title":"","text":"Mint UI 踩坑之路1. Mint UI 之 Cell Swipe 用法 官方API如: Mint UI 之 Cell Swipe Import import { CellSwipe } from &apos;mint-ui&apos; Vue.component(CellSwipe.name, CellSwipe) Example &lt;mt-cell-swipe title=&quot;text&quot; :right=&quot;[ { content: &apos;Delete&apos;, style: { background: &apos;red&apos;, color: &apos;#fff&apos; }, handler: () =&gt; this.$messagebox(&apos;delete&apos;) } ]&quot;&gt;&lt;/mt-cell-swipe&gt; 注意：标签内 handler 中命名的方法，并不能满足我们的需求，可对其进行如下调整，在methods中自定义一个我们所需处理逻辑的方法 &lt;mt-cell-swipe title=&quot;text&quot; v-for=&quot;(item, index) in lists&quot; :key=&quot;index&quot; :right=&quot;[ { content: &apos;Delete&apos;, style: { background: &apos;red&apos;, color: &apos;#fff&apos; }, handler(){deleteItem(index)} // 1.如此修改此handler方法，会调用我们methods中自定义的方法，注：函数名不能命名为delete,严格模式下回报错 } ]&quot;&gt;&lt;/mt-cell-swipe&gt; methods: { deleteItem (index) { // 2.封装自己处理删除单条数据的方法,index为对应item的索引值 console.log(`删除的为数组中的第${index}项`) } } 注意：handler(){ } 中的方法调用，不需要加 this 2. Mint UI 之 Message box 用法 官方API如：Mint UI 之 Message box Import import { MessageBox } from &apos;mint-ui&apos; Vue.prototype.$messagebox = MessageBox Example this.$messagebox.confirm(&apos;&apos;, { message: `是否确认删除${this.applyLists[index].name}模板？`, title: &apos;&apos;, confirmButtonText: &apos;确认&apos;, cancelButtonText: &apos;取消&apos;, className: &apos;myMessage&apos; }).then(action =&gt; { if (action === &apos;confirm&apos;) { // 确认逻辑 } }).catch(err =&gt; { if (err === &apos;cancel&apos;) { // 取消关闭 } })","link":"/2018/02/19/Mint UI踩坑之路/"},{"title":"","text":"常用js代码片段1.获取当前时间（年-月-日 时:分）module.exports = { getNowTime (connector) { // connector 连接符，不传默认为 - if (!connector) connector = &apos;-&apos; const nowTime = new Date() const nowMonth = nowTime.getMonth()+1 &lt; 10 ? &apos;0&apos; + (nowTime.getMonth()+1) : nowTime.getMonth() + 1 const nowDay = nowTime.getDay() &lt; 10 ? &apos;0&apos; + nowTime.getDay() : nowTime.getDay() const nowHours = nowTime.getHours() &lt; 10 ? &apos;0&apos; + nowTime.getHours() : nowTime.getHours() const nowMinute = nowTime.getMinutes() &lt; 10 ? &apos;0&apos; + nowTime.getMinutes() : nowTime.getMinutes() return nowTime.getFullYear() + connector + nowMonth + connector + nowDay + &apos; &apos; + nowHours + &apos;:&apos; + nowMinute } } // 获取结果为： 2018-02-12 17:08 2.向左滑动展示删除按钮功能//向左滑动展示删除会议按钮 function showDeleteWithSlide () { var slideItem = $(&apos;.meetingList&apos;).find(&apos;ul&apos;); var slideStartX=0, slideStartY=0, slideEndX=0, slideEndY=0, slideX=0, slideY=0; slideItem.on(&apos;touchstart&apos;, function (e) { e.stopPropagation(); slideStartX = e.changedTouches[0].clientX; slideStartY = e.changedTouches[0].clientY; }); slideItem.on(&apos;touchmove&apos;, function(e){ e.stopPropagation(); slideEndX = e.changedTouches[0].clientX; slideEndY = e.changedTouches[0].clientY; slideX = slideEndX - slideStartX; slideY = slideEndY - slideStartY; if(Math.abs(slideY) &gt;= Math.abs(slideX)) { //竖向滑动 slideItem.each(function(){ if($(this).hasClass(&apos;show-from-right&apos;)){ $(this).removeClass(&apos;show-from-right&apos;).addClass(&apos;hide-to-right&apos;); if(&apos;meeting_type&apos; == $(this).children(&apos;li:last-child&apos;).attr(&apos;class&apos;) &amp;&amp; $(this).children(&apos;li:last-child&apos;).text()) $(this).children(&apos;li:last-child&apos;).show(); } }) return; //竖向滑动释放默认行为 }; e.preventDefault(); }); slideItem.on(&apos;touchend&apos;, function(e){ e.stopPropagation(); if(slideX&lt;-50){ $(this).removeClass(&apos;hide-to-right&apos;).addClass(&apos;show-from-right&apos;); }else if (slideX&gt;50) { if($(this).hasClass(&apos;show-from-right&apos;)) $(this).removeClass(&apos;show-from-right&apos;).addClass(&apos;hide-to-right&apos;); } if(Math.abs(slideX)&gt;50 &amp;&amp; &apos;meeting_type&apos; == $(this).children(&apos;li:last-child&apos;).attr(&apos;class&apos;) &amp;&amp; &apos;show-from-right&apos; == $(this).attr(&apos;class&apos;)) { $(this).children(&apos;li:last-child&apos;).hide(); }else if(Math.abs(slideX)&gt;50 &amp;&amp; &apos;meeting_type&apos; == $(this).children(&apos;li:last-child&apos;).attr(&apos;class&apos;) &amp;&amp; &apos;hide-to-right&apos; == $(this).attr(&apos;class&apos;) &amp;&amp; $(this).children(&apos;li:last-child&apos;).text()){ $(this).children(&apos;li:last-child&apos;).show(); }; }) }","link":"/2018/02/19/常用代码片段/"},{"title":"","text":"charles连接手机抓包 必须保证电脑和手机在一个局域网下 连接步骤： 打开charles，依次点击 Proxy - Proxy Settings… - 勾选Enable transparent HTTP proxying - ok。 电脑终端 cmd ，输入 ipconfig 查看本机 ip 。 打开手机，连入和电脑相同的局域网关，手动配置http代理，服务器与电脑 ip 保持一致，端口与步骤一Proxy Settings…中的端口号保持一致。 此时charles会给出提示。有新的连接。点击allow。 连接成功，此时手机发送的内容，charles可以抓到。 注意： 然后如果勾选了Proxy - Windows Proxy 的话，那么就会将电脑上的抓包请求也抓取到，如果只抓手机的话，建议取消这个勾选设置。 一百种charles连接不上手机的处理方式： 检查电脑和手机有没有连接的同一个wifi，必须tm连接的一个网 更换charles和移动端设备的端口，默认是8888，可以改成其他的试试 有可能路由器设置的ap间不能相互访问，需要登录路由器，需要登录路由器。进行求改。把用户间访问的对勾勾上。类似于这样 关闭电脑的防火墙。试试 首先，如果，防火墙关了还是不行，那么请把手机wifi断掉后重新连接，这样一般就可以解决问题了。 如果以上方法还是不行的话，那么请将手机wifi位置的ip地址设置成静态ip，然后重启charles工具。 在charles上添加手机的ip试试","link":"/2018/02/19/charles连接手机抓包/"},{"title":"","text":"hello github pages这是 姓名|技能|排行–|：–：|–：刘备|哭|大哥","link":"/2019/01/11/hello-github-pages/"},{"title":"","text":"前后端交互之跨域问题跨域出现的原因：浏览器为安全性考虑而实施的同源策略 ，当协议名，域名，端口号三者中任一一种不相同，就会产生跨域问题。 1. jsonp解决跨域 在 HTML 标签里，一些诸如 script、img 这样的资源的标签是没有跨域限制的，我们利用这一点，绕过 ajax 引擎，从而解决跨域请求 使用 node.js 建立服务 const http = require(&apos;http&apos;); // 导入http内置模块 const server = http.createServer() // 创建一个http服务 server.on(&apos;request&apos;, function(req, res){ // 监听http服务器的request请求 const url = req.url // 获取请求的url if (url === &apos;/xxxxxx&apos;) { var scriptStr = &apos;show()&apos;; // 拼接一个合法的js脚本(前端事先声明好的方法的调用) res.end(scriptStr)； // res.end发送给客户端，客户端去把这个字符串，当作js代码去解析执行 } else { res.end(&apos;404 Not Found!&apos;)； } }) server.listen(3000, function(){ // 指定端口号并启动服务器监听 console.log(&apos;server listen at http://127.0.0.1:3000&apos;)； }) 前端书写规范 &lt;script type=&quot;text/javascript&quot;&gt; function show (data) { // 事先声明好一个处理请求的回调函数，供服务器触发 // 处理请求的逻辑 console.log(data) } &lt;/script&gt; &lt;script src=&quot;http://127.0.0.1:3000/xxxxxx&quot;&gt;&lt;/script&gt; 注意：以上方法，写死了show()方法，不能动态处理请求，升级改造如下： node.js服务升级 const http = require(&apos;http&apos;); const urlModule = require(&apos;url&apos;); // 引入url模块，这个模块能够帮我们解析URL地址，从而拿到 pathname,query const server = http.createServer(); server.on(&apos;request&apos;, function(req, res){ // const url = req.url; // const { pathname, query } = urlModule.parse(req.url, true); // 获取请求的url const { pathname: url, query } = urlModule.parse(req.url, true); // 获取请求的url,并将pathname重命名为url if (url === &apos;/xxxxxx&apos;) { var resData = { // 新增数据对象 name: &apos;xxx&apos;, age: 18 } // var scriptStr = &apos;show()&apos;; var scriptStr = `${query.callback}(${JSON.stringify(resData)})`; // 修改返回值,query.callback就能取到前端callbak对应的函数名 res.end(scriptStr)； } else { res.end(&apos;404 Not Found!&apos;)； } }) server.listen(3000, function(){ console.log(&apos;server listen at http://127.0.0.1:3000&apos;)； }) 前端编码升级 &lt;script type=&quot;text/javascript&quot;&gt; function showInfo (data) { // 事先声明好一个处理请求的回调函数，供服务器触发 // 处理请求的逻辑 console.log(data) } &lt;/script&gt; &lt;script src=&quot;http://127.0.0.1:3000/xxxxxx?callback=showInfo&quot;&gt;&lt;/script&gt; 2. CORS解决跨域详解可参考阮一峰的 跨域资源共享 CORS 详解 服务端设置响应头 Access-Control-Allow-Origin Access-Control-Allow-Origin： http://api.bob.com； // 只允许http://api.bob.com跨域请求 Access-Control-Allow-Origin： *； // 所以的请求都允许跨域请求","link":"/2019/01/11/前后端交互之跨域问题/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2019/03/16/hello-world/"},{"title":"2019-03-17-hello.md","text":"hello hexo","link":"/2019/03/17/2019-03-17-hello-md/"},{"title":"","text":"javascript基础一. js对数组的操作1. 数组的基本操作之 —— 增/删 (push(), pop(), unshift(), shift()) 操作 增： push(): 向数组后添加内容，可接受任意数量的参数，会对原数组产生影响,返回修改后数组的长度 删： pop(): 删除数组最后一个元素，不接收参数，会对原数组产生影响，返回被删除的元素值，如果数组为空，则返回 undefined 增：unshift(): 向数组开头添加内容，可接受任意参数量的参数，会对原数组产生影响，返回修改后的数组的长度 删： shift(): 删除数组第一个元素，不接收参数，会对原数组产生影响，返回被删除的元素值，如果数组为空，则返回 undefined var pushNumber = [1, 2, 3, 4, 5, 6]; var pushResult1 = pushNumber.push(7, &apos;帅气&apos;); console.log(pushResult1); // 8 console.log(pushNumber); // [1, 2, 3, 4, 5, 6, 7, &apos;帅气&apos;] var pushResult2 = pushNumber.unshift([7, &apos;帅气&apos;]); // 注意添加的是一个数组，为一项 console.log(pushResult2); // 9 console.log(pushNumber); // [[7, &apos;帅气&apos;], 1, 2, 3, 4, 5, 6, 7, &apos;帅气&apos;]; var popNumber = [1, 2, 3, 4, 5, 6]; var popResult1 = popNumber.pop(); console.log(popResult1); // 6 console.log(popNumber); // [1, 2, 3, 4, 5] var popResult2 = popNumber.shift(); console.log(popResult2); // 1 console.log(popNumber); // [2, 3, 4, 5] 2. 数组的基本操作之 —— 通过指定索引对指定位置添加或者删除相应位置的元素(splice(), slice()) 说明：splice(): 从数组中添加或删除元素，返回被删除的项目，如果是添加，则返回一个空数组（注：会对原数组进行更改，获取的是新的数组），使用如下：a. 使用splice()方法添加元素：splice(index, 0, data1, data2, …)，添加时，splice()方法返回一个空数组;参数解析： index(插入的元素的起始位置，值为1，就是第一位开始，并非索引值), 0(删除的个数), data1/data2/…(添加的元素)； // 向数组第一项之后插入新值 var spliceAddArr = [1, 2, 3, 4, 5, 6]; var spliceAddResult = spliceAddArr.splice(1, 0, &apos;a&apos;, &apos;b&apos;, &apos;c&apos;); console.log(&apos;spliceAddArr: &apos;, spliceAddArr, &apos;; spliceAddResult: &apos;, spliceAddResult); // spliceAddArr: [1, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, 2, 3, 4, 5, 6] ; spliceAddResult: [] b.1 使用splice()方法删除元素： splice(index, 3)，删除时，splice()方法返回被删除的元素的数组集合（注：会对原数组进行更改，原数组变更为删除之后的新数组）参数解析： index(删除元素的起始位置，值为1，就是从第一位开始，并非索引值)，3(删除的个数)b.2 使用splice()方法删除元素的同时添加元素： splice(index, 3, data1, data2, …)参数解析： index(删除元素的起始位置，值为1，就是从第一位开始，并非索引值)，3(删除的个数)，data1/data2/…（添加的元素）； // 使用splice()删除元素，返回被删除元素 var spliceDelArr = [1, 2, 3, 4, 5, 6]; var spliceDelResult = spliceDelArr.splice(1, 3); console.log(&apos;spliceDelArr: &apos;, spliceDelArr, &apos;; spliceDelResult: &apos;, spliceDelResult); // spliceDelArr: [1, 5, 6] ; spliceDelResult: [2, 3, 4] // 使用splice()删除元素的同时添加元素 var spliceAddArr = [1, 2, 3, 4, 5, 6]; var spliceAddResult = spliceAddArr.splice(1, 3, &apos;a&apos;, &apos;b&apos;, &apos;c&apos;); console.log(&apos;spliceAddArr: &apos;, spliceAddArr, &apos;; spliceAddResult: &apos;, spliceAddResult); // spliceDelArr: [1, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, 5, 6] ; spliceDelResult: [2, 3, 4] 注： 使用splice(),不管是用来添加还是删除元素，第一个参数都可以接受一个负数作为参数，与正数相比：相同之处：使用splice()添加元素，都是从起始位置的之后添加，即如果是正3，即从起始位置往后数3位添加，即从第三第四位中间添加元素，若为负数-3，即从后往前数三位的后一位，即从后往前数第三位到第四位中间添加，如果第一个参数，大于数组的实际长度，则从数组的末尾开始添加。不同之处：使用splice()删除元素，如果是正数3，如： splice(3, 3),即从开始位置往后数三位，从第四位开始删除三项，实际删除的是第四，第五，第六项，而当为负数-3时，如： splice(-3, 3)，即从后往前数三位，从倒数第三位开始删除，并不是倒数第四位，实际删除的项为倒数第三项，倒数第二项，倒数第一项三项。如果删除的项数大于起始位置到数组的结束位置的项数，则默认到数组结束位置停止。 // splice()添加，index为正数时 var arr1 = [1, 2, 3, 4, 5]; var arrRes1 = arr1.splice(3, 0, &apos;a&apos;, &apos;b&apos;, &apos;c&apos;); console.log(&apos;arr1: &apos;, arr1, &apos;; arrRes1:&apos;, arrRes1); // arr1: [1, 2, 3, &apos;a&apos;, &apos;b&apos;, &apos;c&apos;, 4, 5] ； arrRes1： [] // splice()添加，index为负数时 var arr2 = [1, 2, 3, 4, 5]; var arrRes2 = arr2.splice(-3, 0, &apos;a&apos;, &apos;b&apos;, &apos;c&apos;); console.log(&apos;arr2: &apos;, arr2, &apos;; arrRes2:&apos;, arrRes2); // arr2: [1, 2, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, 3, 4, 5] ; arrRes2: [] // splice()删除，index为正数时 var arr3 = [1, 2, 3, 4, 5, 6, 7]; var arrRes3 = arr3.splice(3, 3, &apos;a&apos;, &apos;b&apos;, &apos;c&apos;); console.log(&apos;arr3: &apos;, arr3, &apos;; arrRes3:&apos;, arrRes3); // arr3: [1, 2, 3, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, 7] ； arrRes3： [4, 5, 6] // splice()删除，index为正数时 var arr4 = [1, 2, 3, 4, 5, 6, 7]; var arrRes4 = arr4.splice(-3, 3, &apos;a&apos;, &apos;b&apos;, &apos;c&apos;); console.log(&apos;arr4: &apos;, arr4, &apos;; arrRes4:&apos;, arrRes4); // arr3: [1, 2, 3, 4, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;] ； arrRes3： [5, 6, 7] slice()使用说明：用于截取数组，返回截取到的新的数组，此方法可以作用于字符串属性（注：不会影响原数组）;此方法接受两个参数，slice(start, end)：start: 必传，截取开始位置的下标,end: 可传，截取结束的位置下标索引，不包括当前下标对应的元素，不传为数组结束。 var sliceArr = [1, 2, 3, 4, 5, 6, 7]; var sliceRes0 = sliceArr.slice(2); // 实际截取的为：第三项到数组结束 var sliceRes1 = sliceArr.slice(2, 4); // 实际截取的为：第三项，第四项 var sliceRes2 = sliceArr.slice(-2); // 实际截取的为：第三项，第四项 var sliceRes3 = sliceArr.slice(-9); // 从后往前第九位，数组长度不够，从第一项开始截取到数组结束 var sliceRes4 = sliceArr.slice(-4, -2); // 实际截取的为从倒数第四项到倒数第二项：即为倒数第四项，倒数第五项两项 var sliceRes5 = sliceArr.slice(-4, -6); // 无匹配项，返回一个空数组 var sliceRes6 = sliceArr.slice(1, -2); // 从索引为1的位置开始，到倒数第二项，不包括倒数第二项 var sliceRes7 = sliceArr.slice(9); // 无匹配项，返回一个空数组 console.log(&apos;sliceArr: &apos;, sliceArr, &apos;； sliceRes0: &apos;, sliceRes0); // sliceArr1: [1, 2, 3, 4, 5, 6, 7] ; sliceRes0: [3, 4, 5, 6, 7] console.log(&apos;sliceRes1: &apos;, sliceRes1); // sliceRes1: [3, 4] console.log(&apos;sliceRes2: &apos;, sliceRes2); // sliceRes2: [6, 7] console.log(&apos;sliceRes3: &apos;, sliceRes3); // sliceRes3: [1, 2, 3, 4, 5, 6, 7] console.log(&apos;sliceRes4: &apos;, sliceRes4); // sliceRes4: [4, 5] console.log(&apos;sliceRes5: &apos;, sliceRes5); // sliceRes5: [] console.log(&apos;sliceRes6: &apos;, sliceRes6); // sliceRes6: [2, 3, 4, 5] console.log(&apos;sliceRes7: &apos;, sliceRes7); // sliceRes7: [] 3. 数组的基本操作之 —— 对数组的每一项进行操作(map(), forEach()) 相同点: 都是循环遍历数组中每一项 map和forEach每次执行匿名函数时都支持3个参数，参数分别是item(当前项)，index(索引值)，arr(原数组) 匿名函数中的this都指向 window 只能遍历数组 都不会改变原数组 区别：map方法： map方法返回一个新的数组，数组中的元素为原始数组调用函数处理之后的值 map方法不会对空数组进行检测(即不会执行匿名函数，若为空数组，则调用map方法后也返回一个空数组)，map方法不会改变原始数组 浏览器支持： chrome / Safari 1.5+ / opera / IE9+forEach方法： forEach()方法用来调用数组的每个元素，将元素传给回调函数 forEach()方法不会对空数组进行检测，对于空数组是不会调用匿名函数的，注意，无论数组是否为空，调用forEach方法，返回值均为 undefined // map方法 var mapArr = [1, 2, 3, 4, 5]; var mapResult = mapArr.map(function(item, index, arr){ console.log(this); // window console.log(&apos;原始数组mapArr: &apos;, arr); // 原始数组mapArr: [1, 2, 3, 4, 5] return item+1; }) console.log(&apos;mapArr:&apos;, mapArr, &apos;; mapResult: &apos;, mapResult); // mapArr: [1, 2, 3, 4, 5] ; mapResult: [2, 3, 4, 5, 6] // 若为空数组，调用map方法，返回一个空数组，匿名函数不会执行 var empArr = []; var mapEmpResult = empArr.map(function(){item, index, arr}{ // 空数组调用map方法，函数体不会执行 console.log(this); console.log(&apos;原始数组mapArr: &apos;, arr); return item+1; })； console.log(&apos;empArr:&apos;, empArr, &apos;; mapEmpResult: &apos;, mapEmpResult); // empArr: [] ; mapEmpResult: [] // forEach方法 var forEachArr = [1, 2, 3, 4, 5]; var forEachResult = forEachArr.forEach(function(item, index, arr){ // 调用forEach()方法，返回值均为 undefined console.log(this); // window console.log(&apos;原始数组forEachArr：&apos;, arr); // 原始数组forEachArr： [1, 2, 3, 4, 5] return item+1; }) console.log(&apos;forEachArr:&apos;, forEachArr, &apos;; forEachResult: &apos;, forEachResult); // forEachArr: [1, 2, 3, 4, 5] ; forEachResult: undefined 4. 数组的基本操作之 —— 对数组的每一项进行操作（ filter() ） 说明： 遍历每一项数组，接收一个匿名函数作为参数，函数接收三个参数，参数item(遍历得到的每一项数组值)，index（索引值），arr(数组本身)， 返回一个结果为true的item组成的新数组，不会影响原数组 // 需求：获取成绩合格的学生名单 var students = [ {name: &apos;张三&apos;, age: 18, scroe: 89}, {name: &apos;李四&apos;, age: 17, scroe: 71}, {name: &apos;王五&apos;, age: 18, scroe: 56}, {name: &apos;赵六&apos;, age: 19, scroe: 94}, {name: &apos;小明&apos;, age: 18, scroe: 48}, {name: &apos;小红&apos;, age: 19, scroe: 60}, ]; var studentsResult = students.filter(function(item){ if (item.scroe &gt;= 60) { return { name: item.name, age: item.age, score: item.scroe } } }); console.log(studentsResult); // 输出如下结果 // [{name: &quot;张三&quot;, age: 18, scroe: 89}, // {name: &quot;李四&quot;, age: 17, scroe: 71}, // {name: &quot;赵六&quot;, age: 19, scroe: 94}, // {name: &quot;小红&quot;, age: 19, scroe: 60}] 5. 数组的基本操作之 —— 对数组的迭代方法(every(), some())方法 说明：every()和some()都是对js中数组的迭代方法，区别如下：相同点： 均接收一个匿名函数作为参数，函数接收三个参数，参数item(每一项),index（索引值），arr(原始数组) 均对数组的每一项运行指定的匿名函数 不同点:every(): 对数组的每一项运行给定的函数，如果该函数每一项都返回 true, 则返回 true，若存在某项返回false，则终止函数迭代，返回false; (可用来判断是不是所有，类似于逻辑 &amp;&amp;)some(): 对数组的每一项运行给定的函数，如果该函数存在某一项返回 true, 函数终止，并返回 true; (可用来判断有没有，类似于逻辑 ||) // 判断数组是是否全为基数 // 使用every()方法实现 var everyArr1 = [1, 3, 5, 7, 9]; var everyArr2 = [1, 3, 5, 6, 7, 9]; var everyResult1 = everyArr1.every(function(item, index, arr){ if (!(item % 2)) { console.log(&apos;第&apos;+(index+1)+&apos;项为偶数,值为：&apos;+item); } return item % 2; }); var everyResult2 = everyArr2.every(function(item, index, arr){ if (!(item % 2)) { console.log(&apos;第&apos;+(index+1)+&apos;项为偶数,值为：&apos;+item); // 第4项为偶数,值为：6 } return item % 2; }); console.log(everyResult1?&apos;everyArr1的每一项均为基数&apos;:&apos;everyArr1的存在某一项不为基数&apos;); // everyArr的每一项均为基数 console.log(everyResult2?&apos;everyArr2的每一项均为基数&apos;:&apos;everyArr2的存在某一项不为基数&apos;); // everyArr2的存在某一项不为基数 // 使用some()方法实现 var someArr1 = [1, 3, 5, 7, 9]; var someArr2 = [1, 3, 5, 6, 7, 9]; var someResult1 = someArr1.some(function (item, index, arr) { if (!(item % 2)) { console.log(&apos;第&apos; + (index + 1) + &apos;项为偶数,值为：&apos; + item); }; return !(item % 2); }); var someResult2 = someArr2.some(function (item, index, arr) { if (!(item % 2)) { console.log(&apos;第&apos; + (index + 1) + &apos;项为偶数,值为：&apos; + item); // 第4项为偶数,值为：6 }; return !(item % 2); }); console.log(!someResult1 ? &apos;someArr1的每一项均为基数&apos; : &apos;someArr1的存在某一项不为基数&apos;); // someArr1的每一项均为基数 console.log(!someResult2 ? &apos;someArr2的每一项均为基数&apos; : &apos;someArr2的存在某一项不为基数&apos;); // someArr2的存在某一项不为基数","link":"/2017/08/05/javascript基础之数组的操作/"}],"tags":[],"categories":[]}